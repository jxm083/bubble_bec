(* ::Package:: *)

(* ::Title:: *)
(*chip-trap adiabatic potentials for NASA/CAL *)


(* ::Text:: *)
(*This package forked from bubble-4a-murphree.nb on 15 July 2020.*)


(* ::Section::Closed:: *)
(*units and constants*)


(* ::Input:: *)
(*\[Mu]m=10^-6;*)
(*Gauss=10^-4;*)
(*G= Gauss;*)
(*cm = .01;*)
(*mA=mm=10^-3;*)
(*A=1;*)
(*\[Mu]0=4\[Pi] 10^-7;*)
(*h = 6.62606957 10^-34;*)
(*hbar = h /(2 \[Pi]);*)
(*\[HBar]=hbar;*)
(*kb = 1.3806488*^-23;*)
(*mRb =1.443160648*^-25;*)
(*\[Mu]B=9.27400968*^-24;*)
(*gfactor=1/2;*)
(*gF = 1/2; (* not accurate to .0001 *) *)
(*gF= gJ (F(F+1)-Inuc(Inuc+1)+J(J+1))/(2F(F+1))+gI (F(F+1)+Inuc(Inuc+1)-J(J+1))/(2F(F+1)) /. {F->2,J->1/2};*)
(*Inuc= 3/2;*)
(*Ahfs =  3.417341305*^9;*)
(*gI= -.0009951414 ;*)
(*gJ = 2.00233113;*)
(*nKPerHz = 1*^9(h/kb);*)
(**)
(**)
(**)
(**)
(**)
(**)
(*<<NathanSettings`*)


(* ::Section:: *)
(*three-level rotating-frame & RWA Hamiltonian (F = 1; toy)*)


(* ::Input:: *)
(*H0=({*)
(* {Eminus1, 0, 0},*)
(* {0, E0, 0},*)
(* {0, 0, Eplus1}*)
(*});*)
(*V= ({*)
(* {-\[CapitalDelta],  \[CapitalOmega]/2 , 0},*)
(* {\[CapitalOmega] /2 , 0, \[CapitalOmega]/2 },*)
(* {0, \[CapitalOmega]/2, \[CapitalDelta]}*)
(*}); (* 1cm coil a few mm away from atoms *)*)
(*H = H0+V;*)
(**)
(*Print["limiting-case symmetric eigenvalues: ",FullSimplify[Eigenvalues[H /.{E0->0,Eplus1->-Eminus1}],{Eminus1>0,\[CapitalOmega]>0}]]*)
(**)
(*ZeemanShift[Field_]:= {*)
(*Ahfs+ ( -gI \[Mu]B Field/h-Ahfs \[Sqrt](1-((gJ-gI)\[Mu]B/Ahfs/h/2) Field+( (gJ-gI)\[Mu]B/Ahfs/h/2)^2 Field^2)),*)
(*Ahfs-Ahfs Sqrt[1+((gJ-gI)\[Mu]B/Ahfs/h/2)^2 Field^2],*)
(*Ahfs+ (gI \[Mu]B Field/h-Ahfs \[Sqrt](1+((gJ-gI)\[Mu]B/Ahfs/h/2) Field+( (gJ-gI)\[Mu]B/Ahfs/h/2)^2 Field^2))} (* F=1, m= -1, 0, +1 *)*)
(**)
(**)
(*Plot[ZeemanShift[Field]/1*^6,{Field,0,100 Gauss},Frame->True,FrameLabel->{"B [Tesla]","MHz"},AspectRatio->1]*)


(* ::Section:: *)
(*Zeeman-shift formulae (Breit-Rabi) *)


(* ::Input:: *)
(*k = ((gJ-gI)\[Mu]B/Ahfs/h/2);*)
(*\[CapitalXi][Field_]:= If[Field>= 1/k, -1,1];*)
(*Clear[ZeemanShift];*)
(**)
(*ZeemanShift[Field_]= {*)
(*-Ahfs-2gI \[Mu]B Field/h+\[CapitalXi][Field]Ahfs Sqrt[1- 2k Field+k^2 Field^2],*)
(*-Ahfs-gI \[Mu]B Field/h+Ahfs Sqrt[1- k Field+k^2 Field^2],*)
(*-Ahfs+Ahfs Sqrt[1+k^2 Field^2],*)
(*-Ahfs+ gI \[Mu]B Field/h+Ahfs Sqrt[1+k  Field+k^2 Field^2],*)
(*-Ahfs+ 2 gI \[Mu]B Field/h+ Ahfs Sqrt[1+2k  Field+k^2 Field^2]*)
(*}; (* F=2, m= -2, -1, 0, +1, +2 *)*)
(*ZeemanShiftC = Compile[{Field},Evaluate[ZeemanShift[Field]]];  *)
(*Plot[{ZeemanShift[Field]/1*^6,0, gF(\[Mu]B/h/1*^6) Field,-gF(\[Mu]B/h/1*^6) Field},{Field,0,5000 Gauss},FrameLabel->{"B (Tesla)","MHz"},PlotStyle->{Blue,Dashed,Dashed,Dashed},FrameTicksStyle->Directive[Black,FontFamily->"Century Gothic"],FrameStyle->Directive[Black,15,FontFamily->"Century Gothic"],AspectRatio->1,PlotRange->All,Axes->False]*)


(* ::Section:: *)
(*magnetic field from the chip (i)*)


(* ::Subsection:: *)
(*Biot-Savart Functions*)


(* ::Input:: *)
(*(* Function FatXwire calculates the B-field at position (x0,y0,z0) for a conductor of width 2*hw at position y=yc running a finite length in x from x1\[Rule]x2. We assume the conductor lies in the plane z=0. *)*)
(*FatXwire[x0_,y0_,z0_,hw_,yc_,x1_,x2_]:=Module[{dx1,dx2,dyPlus,dyMinus},*)
(*dx1=-(x0-x1);*)
(*dx2=-(x0-x2);*)
(*dyPlus=-(y0-(yc+hw));*)
(*dyMinus=y0-(yc-hw);*)
(*Return[10^-3/(2hw) {0,ArcTan[(dx1 dyMinus)/(z0 Sqrt[dx1^2+dyMinus^2+z0^2])]-ArcTan[(dx2 dyMinus)/(z0 Sqrt[dx2^2+dyMinus^2+z0^2])]+ArcTan[(dx1 dyPlus)/(z0 Sqrt[dx1^2+dyPlus^2+z0^2])]-ArcTan[(dx2 dyPlus)/(z0 Sqrt[dx2^2+dyPlus^2+z0^2])],Log[(dx1+Sqrt[dx1^2+dyMinus^2+z0^2])/(dx2+Sqrt[dx2^2+dyMinus^2+z0^2]) (dx2+Sqrt[dx2^2+dyPlus^2+z0^2])/(dx1+Sqrt[dx1^2+dyPlus^2+z0^2])]}];*)
(*];*)


(* ::Input:: *)
(*(* Function FatYwire calculates the magnetic field at position (x0,y0,z0) of a rectangular conductor with finite width 2*hw.  We assume: (1) Current flows in the y direction from y1 \[Rule] y2; (2) The conductor is centered at x=xc and has width 2*hw; (3) The conductor lies entirely in the x-y plane (i.e. z=0). *)*)
(*FatYwire[x0_,y0_,z0_,hw_,xc_,y1_,y2_]:=Module[{dxPlus,dxMinus,dy1,dy2},*)
(*dxPlus=hw+x0-xc;*)
(*dxMinus=hw-x0+xc;*)
(*dy1=y0-y1;*)
(*dy2=-y0+y2;*)
(*Return[10^-3/(2 hw) {ArcTan[(dxPlus dy1)/(z0 Sqrt[dxPlus^2+dy1^2+z0^2])]+ArcTan[(dxMinus dy1)/(z0 Sqrt[dxMinus^2+dy1^2+z0^2])]+ArcTan[(dxPlus dy2)/(z0 Sqrt[dxPlus^2+dy2^2+z0^2])]+ArcTan[(dxMinus dy2)/(z0 Sqrt[dxMinus^2+dy2^2+z0^2])],0,-Log[(-dy1+Sqrt[dxPlus^2+dy1^2+z0^2])/(-dy1+Sqrt[dxMinus^2+dy1^2+z0^2]) (dy2+Sqrt[dxMinus^2+dy2^2+z0^2])/(dy2+Sqrt[dxPlus^2+dy2^2+z0^2])]}];*)
(*];*)


(* ::Subsection:: *)
(*Wire Pattern*)


(* ::Text:: *)
(*Pick a coordinate system: "x" is the direction of the main chip wire, and "y" is the direction current flows along the dimple.*)


(* ::Subsubsection::Closed:: *)
(*FLIGHT CHIP    T - TRAP?*)


(* ::Input:: *)
(*ChipTrapField[x_,y_,z_,Ix_,Iy_,Bx_,By_,Bz_]:=Module[{VecField},*)
(*VecField=*)
(*    Ix*FatXwire[x,y,z,50\[Mu]m,0,-4.5mm,+3.5mm] (* main section of Z wire *)*)
(*+Ix*FatYwire[x,y,z,50\[Mu]m,-4.5mm,-10mm,0mm] (* first leg of Z wire *)*)
(*+Ix*FatYwire[x,y,z,50\[Mu]m,3.5mm,0mm,10mm] (* second leg of Z wire *)*)
(*+Iy*FatYwire[x,y,z,50\[Mu]m,0,-10mm,0mm]+{Bx,By,Bz}; (* T wire *)*)
(*+Iy*FatXwire[x,y,z,50\[Mu]m,0,0mm,3.5mm]+{Bx,By,Bz}; (* T wire *)*)
(*Return[Sqrt[VecField.VecField]]*)
(*]*)
(**)
(*ChipTrapVecField[x_,y_,z_,Ix_,Iy_,Bx_,By_,Bz_]:=Module[{VecField},*)
(*VecField=*)
(*    Ix*FatXwire[x,y,z,50\[Mu]m,0,-4.5mm,+3.5mm] (* main section of Z wire *)*)
(*+Ix*FatYwire[x,y,z,50\[Mu]m,-4.5mm,-10mm,0mm] (* first leg of Z wire *)*)
(*+Ix*FatYwire[x,y,z,50\[Mu]m,3.5mm,0mm,10mm] (* second leg of Z wire *)*)
(*+Iy*FatYwire[x,y,z,50\[Mu]m,0,-10mm,0mm]+{Bx,By,Bz}; (* T wire *)*)
(*+Iy*FatXwire[x,y,z,50\[Mu]m,0,0mm,3.5mm]+{Bx,By,Bz}; (* T wire *)*)
(*Return[VecField]*)
(*]*)


(* ::Subsubsection:: *)
(*FLIGHT CHIP H - TRAP*)


(* ::Input:: *)
(*XXGrad = 0.00005(* in G/cm *) ;*)
(*YYGrad=0.00005;*)
(*ZZGrad = 0.00005;*)
(*ZYGrad = 0.00005;*)
(*XGrad=XXGrad;*)
(*ZGrad=ZZGrad;*)
(*YGrad=YYGrad;*)
(**)
(*ChipTrapField[x_,y_,z_,Ix_,Iy_,Bx_,By_,Bz_]:=Module[{VecField},*)
(*VecField=*)
(*   Ix*FatXwire[x,y,z,50\[Mu]m,0,-13.3mm/2,+13.3mm/2] (* main section of Z wire *)*)
(*+ Ix*FatYwire[x,y,z,50\[Mu]m,-13.3mm/2,-12mm,0mm] (* first leg of Z wire *)*)
(*+ Ix*FatYwire[x,y,z,50\[Mu]m,13.3mm/2,0mm,12mm] (* second leg of Z wire *)*)
(*+Iy*FatYwire[x,y,z+425 \[Mu]m,200\[Mu]m,-1.6mm,-12mm,12mm] (* first leg of H *)*)
(*+Iy*FatYwire[x,y,z+425 \[Mu]m,200\[Mu]m,1.6mm,-12mm,12mm] (* second leg of H *)*)
(*+{Bx,By,Bz}+{100 XGrad x , 100 YGrad y ,100 ZGrad z+100ZYGrad y};*)
(*Return[Sqrt[VecField.VecField]]*)
(*]*)
(**)
(*ChipTrapVecField[x_,y_,z_,Ix_,Iy_,Bx_,By_,Bz_]:=Module[{VecField},*)
(*VecField=*)
(*   Ix*FatXwire[x,y,z,50\[Mu]m,0,-13.3mm/2,+13.3mm/2] (* main section of Z wire *)*)
(*+ Ix*FatYwire[x,y,z,50\[Mu]m,-13.3mm/2,-12mm,0mm] (* first leg of Z wire *)*)
(*+ Ix*FatYwire[x,y,z,50\[Mu]m,13.3mm/2,0mm,12mm] (* second leg of Z wire *)*)
(*+Iy*FatYwire[x,y,z+425 \[Mu]m,200\[Mu]m,-1.6mm,-12mm,12mm] (* first leg of 2nd Z wire *)*)
(*+Iy*FatYwire[x,y,z+425 \[Mu]m,200\[Mu]m,1.6mm,-12mm,12mm] (* second leg of 2nd Z wire *)*)
(*+{Bx,By,Bz}+{100 XXGrad x ,100 YYGrad y ,100ZZGrad z+100ZYGrad y};*)
(*Return[VecField]*)
(*]*)
(**)


(* ::Input:: *)
(*(* Plot3D[ChipTrapField[x,y,0.0005,-3.3,-1.3,-22.6 ,-1.6 22.6,0],{x,-10mm,10mm},{y,-1mm,1mm},PlotRange\[Rule]All,PlotPoints\[Rule]40]  *)*)


(* ::Input:: *)
(**)


(* ::Input:: *)
(**)


(* ::Subsubsection:: *)
(*SM3*)


(* ::Input:: *)
(*XXGrad = 0.00005(* in G/cm *) ;*)
(*YYGrad=0.00005;*)
(*ZZGrad = 0.00005;*)
(*ZYGrad = 0.00005;*)
(*XGrad=XXGrad;*)
(*ZGrad=ZZGrad;*)
(*YGrad=YYGrad;*)
(**)
(*Hoffset = -425 \[Mu]m;*)
(*WireWidth = 50 \[Mu]m; (*half-width*)*)
(**)
(*ChipTrapField[x_,y_,z_,Ilb_,Izb_,Ih_,Bx_,By_,Bz_]:=Module[{VecField},*)
(* VecField=*)
(*   Izb FatXwire[x,y,z,WireWidth,0,-5.5mm,+5.5mm] (* main section of Z wire *)*)
(*+ Izb FatYwire[x,y,z,WireWidth,-5.5mm,-5mm,0 mm] (* first leg of Z wire *)*)
(*+ Izb FatYwire[x,y,z,WireWidth,5.5mm,0mm,5mm] (* second leg of Z wire *)*)
(*+Ih FatYwire[x,y,z-Hoffset,200\[Mu]m,-1.5mm,5mm,-5mm] (* first leg of H *)*)
(*+Ih FatYwire[x,y,z-Hoffset,200\[Mu]m,1.5mm,5mm,-5mm] (* second leg of H *)*)
(*+ Ilb FatXwire[x,y,z,WireWidth,-150 \[Mu]m,75 \[Mu]m,+5.5mm] (* main section of L wire *)*)
(*+ Ilb FatYwire[x,y,z,WireWidth,75 \[Mu]m,-5mm,-150\[Mu]m] (* first leg of L wire *)*)
(*+ Ilb FatYwire[x,y,z,WireWidth,5.5mm,-150 \[Mu]m,-5mm] (* second leg of L wire *)*)
(*+{Bx,By,Bz}+{100 XGrad x , 100 YGrad y ,100 ZGrad z+100ZYGrad y};*)
(*Return[Sqrt[VecField.VecField]]*)
(*]*)
(**)
(*ChipTrapVecField[x_,y_,z_,Ilb_,Izb_,Ih_,Bx_,By_,Bz_]:=Module[{VecField},*)
(* VecField=*)
(*   Izb FatXwire[x,y,z,WireWidth,0,-5.5mm,+5.5mm] (* main section of Z wire *)*)
(*+ Izb FatYwire[x,y,z,WireWidth,-5.5mm,-5mm,0 mm] (* first leg of Z wire *)*)
(*+ Izb FatYwire[x,y,z,WireWidth,5.5mm,0mm,5mm] (* second leg of Z wire *)*)
(*+Ih FatYwire[x,y,z-Hoffset,200\[Mu]m,-1.5mm,5mm,-5mm] (* first leg of H *)*)
(*+Ih FatYwire[x,y,z-Hoffset,200\[Mu]m,1.5mm,5mm,-5mm] (* second leg of H *)*)
(*+ Ilb FatXwire[x,y,z,WireWidth,-150 \[Mu]m,75 \[Mu]m,+5.5mm] (* main section of L wire *)*)
(*+ Ilb FatYwire[x,y,z,WireWidth,75 \[Mu]m,-5mm,-150\[Mu]m] (* first leg of L wire *)*)
(*+ Ilb FatYwire[x,y,z,WireWidth,5.5mm,-150 \[Mu]m,-5mm] (* second leg of L wire *)*)
(*+{Bx,By,Bz}+{100 XGrad x , 100 YGrad y ,100 ZGrad z+100ZYGrad y};*)
(*Return[VecField]*)
(*]*)
(**)
(*ChipTrapFieldAAndB[x_,y_,z_,Ila_,Iza_,Ilb_,Izb_,Ih_,Bx_,By_,Bz_]:=Module[*)
(*{VecField,*)
(*ZLength,LLength,LegLength,deltaL,*)
(*ZAMainyc,ZAMainx0,ZAMainx1,*)
(*ZALeg1xc,ZALeg1y0,ZALeg1y1,*)
(*ZALeg2xc,ZALeg2y0,ZALeg2y1,*)
(*LAMainyc,LAMainx0,LAMainx1,*)
(*LALeg1xc,LALeg1y0,LALeg1y1,*)
(*LALeg2xc,LALeg2y0,LALeg2y1,*)
(*ZBMainyc,ZBMainx0,ZBMainx1,*)
(*ZBLeg1xc,ZBLeg1y0,ZBLeg1y1,*)
(*ZBLeg2xc,ZBLeg2y0,ZBLeg2y1,*)
(*LBMainyc,LBMainx0,LBMainx1,*)
(*LBLeg1xc,LBLeg1y0,LBLeg1y1,*)
(*LBLeg2xc,LBLeg2y0,LBLeg2y1},*)
(*ZLength=11.55mm;*)
(*LLength=5.875mm;*)
(*LegLength=5mm;*)
(*deltaL=150\[Mu]m;(* Distance between the centers of two adjacent wires *)*)
(**)
(*{LALeg1xc,LALeg1y0,LALeg1y1}={-deltaL/2,2000\[Mu]m+deltaL+LegLength,2000\[Mu]m+deltaL}; (* Took separation of lines before the bend, which is indicated in the diagram, to be the same after the bend. *)*)
(*{LAMainyc,LAMainx0,LAMainx1}={LALeg1y1,LALeg1xc,LALeg1xc-LLength};*)
(*{LALeg2xc,LALeg2y0,LALeg2y1}={LAMainx1,LAMainyc,LALeg1y0};*)
(**)
(*{ZAMainyc,ZAMainx0,ZAMainx1}={2000\[Mu]m,-deltaL/2-LLength+ZLength,-deltaL/2-LLength};*)
(*{ZALeg1xc,ZALeg1y0,ZALeg1y1}={ZAMainx0,ZAMainyc+LegLength,ZAMainyc};*)
(*{ZALeg2xc,ZALeg2y0,ZALeg2y1}={ZAMainx1,ZAMainyc,ZAMainyc-LegLength};*)
(**)
(*{LBLeg1xc,LBLeg1y0,LBLeg1y1}={deltaL/2,-deltaL-LegLength,-deltaL};*)
(*{LBMainyc,LBMainx0,LBMainx1}={LBLeg1y1,LBLeg1xc,LBLeg1xc+LLength};*)
(*{LBLeg2xc,LBLeg2y0,LBLeg2y1}={LBMainx1,LBMainyc,LBLeg1y0};*)
(**)
(*{ZBMainyc,ZBMainx0,ZBMainx1}={0,deltaL/2+LLength-ZLength,deltaL/2+LLength};*)
(*{ZBLeg1xc,ZBLeg1y0,ZBLeg1y1}={ZBMainx0,ZBMainyc-LegLength,ZBMainyc};*)
(*{ZBLeg2xc,ZBLeg2y0,ZBLeg2y1}={ZBMainx1,ZBMainyc,ZBMainyc+LegLength};*)
(**)
(**)
(**)
(* VecField=( *)
(*Iza FatXwire[x,y,z,WireWidth,ZAMainyc,ZAMainx0,ZAMainx1](* main section of ZA wire *)*)
(*+ Iza FatYwire[x,y,z,WireWidth,ZALeg1xc,ZALeg1y0,ZALeg1y1](* first leg of ZA wire *)*)
(*+Iza FatYwire[x,y,z,WireWidth,ZALeg2xc,ZALeg2y0,ZALeg2y1](* second leg of ZA wire *)*)
(**)
(*+Ila FatXwire[x,y,z,WireWidth,LAMainyc,LAMainx0,LAMainx1](* main section of LA wire *)*)
(*+Ila FatYwire[x,y,z,WireWidth,LALeg1xc,LALeg1y0,LALeg1y1](* first leg of LA wire *)*)
(*+Ila FatYwire[x,y,z,WireWidth,LALeg2xc,LALeg2y0,LALeg2y1](* second leg of LA wire *)*)
(**)
(*+Izb FatXwire[x,y,z,WireWidth,ZBMainyc,ZBMainx0,ZBMainx1](* main section of ZB wire *)*)
(*+ Izb FatYwire[x,y,z,WireWidth,ZBLeg1xc,ZBLeg1y0,ZBLeg1y1](* first leg of ZB wire *)*)
(*+Izb FatYwire[x,y,z,WireWidth,ZBLeg2xc,ZBLeg2y0,ZBLeg2y1](* second leg of ZB wire *)*)
(**)
(*+Ilb FatXwire[x,y,z,WireWidth,LBMainyc,LBMainx0,LBMainx1](* main section of LB wire *)*)
(*+Ilb FatYwire[x,y,z,WireWidth,LBLeg1xc,LBLeg1y0,LBLeg1y1](* first leg of LB wire *)*)
(*+Ilb FatYwire[x,y,z,WireWidth,LBLeg2xc,LBLeg2y0,LBLeg2y1](* second leg of LB wire *)*)
(**)
(*+Ih FatYwire[x,y,z-Hoffset,200\[Mu]m,-1.5mm,5mm,-5mm] (* first leg of H *)*)
(*+Ih FatYwire[x,y,z-Hoffset,200\[Mu]m,1.5mm,5mm,-5mm] (* second leg of H *)*)
(**)
(*+{Bx,By,Bz}+{100 XGrad x , 100 YGrad y ,100 ZGrad z+100ZYGrad y});(* Bias fields and field gradients *)*)
(*Return[Sqrt[VecField.VecField]]*)
(*]*)
(**)


(* ::Subsection:: *)
(*UNDO THIS*)


(* ::Input:: *)
(*(* ChipTrapField[x_,y_,z_,Ilb_,Izb_,Ih_,Bx_,By_,Bz_]:=ChipTrapFieldAAndB[x,y,z,0,0,Ilb,Izb,Ih,Bx,By,Bz] *)*)


(* ::Input:: *)
(*plotBound=6.5;*)
(*Plot3D[ChipTrapFieldAAndB[x mm,y mm,.005 mm,CurrL,CurrZ,CurrL,CurrZ,CurrH,Bx1,By1,Bz1 ],{x,-plotBound,plotBound},{y,-plotBound,plotBound},PlotRange->All,PlotPoints->30,AxesLabel->{"X","Y","B"}, BoundaryStyle->Directive[Green,Thick],AspectRatio->1]*)


(* ::Input:: *)
(*plotBound=0.5;*)
(*Plot3D[ChipTrapFieldAAndB[x mm,y mm,.005 mm,CurrL,CurrZ,CurrL,CurrZ,CurrH,Bx1,By1,Bz1 ],{x,-plotBound,plotBound},{y,-plotBound,plotBound},PlotRange->All,PlotPoints->30,AxesLabel->{"X","Y","B"}, BoundaryStyle->Directive[Green,Thick],AspectRatio->1]*)


(* ::Input:: *)
(*Plot3D[ChipTrapFieldAAndB[x mm,y mm,.005 mm,CurrL,CurrZ,CurrL,CurrZ,CurrH,Bx1,By1,Bz1 ],{x,-plotBound,plotBound},{y,-plotBound+2,plotBound+2},PlotRange->All,PlotPoints->30,AxesLabel->{"X","Y","B"}, BoundaryStyle->Directive[Green,Thick],AspectRatio->1]*)


(* ::Input:: *)
(*(* Helps position cloud (the ellipsoid, though it will appear as an x-y cross-section at 0.005mm) within the trapping potential.?*)*)
(*Show[{Plot3D[ChipTrapField[x mm,y mm,.005 mm,CurrL,CurrZ, CurrH,Bx1,By1,Bz1 ],{x,-.5,.5},{y,-.5,.5},PlotRange->All,PlotPoints->30,AxesLabel->{"X","Y","B"}, BoundaryStyle->Directive[Green,Thick],AspectRatio->1]  ,Graphics3D[Ellipsoid[{x1 /mm,y1/ mm,ChipTrapField[x1,y1,z1,CurrL,CurrZ,CurrH,Bx1,By1,Bz1]},{.2,.2,1}]]}]*)


(* ::Input:: *)
(*ContourPlot[Abs[ChipTrapField[x mm,y mm,.001 mm,1,1, 0,0,0,0 ]],{x,-.5,.5},{y,-.5,.5},PlotRange->All,PlotPoints->15,Contours->20,AxesLabel->{"X","Y"}] *)


(* ::Input:: *)
(**)


(* ::Subsubsection:: *)
(*GTB CHIP    x - TRAP (this is now the flight chip)?*)


(* ::Input:: *)
(*ChipTrapField[x_,y_,z_,Ix_,Iy_,Bx_,By_,Bz_]:=Module[{VecField},*)
(*VecField=*)
(*    Ix*FatXwire[x,y,z,50\[Mu]m,0,-1.075mm,+1.075mm] (* main section of Z wire *)*)
(*+Ix*FatYwire[x,y,z,50\[Mu]m,-1.075 mm,-6mm,0mm] (* first leg of Z wire *)*)
(*+Ix*FatYwire[x,y,z,50\[Mu]m,1.075mm,0mm,6mm] (* second leg of Z wire *)*)
(*+Iy*FatYwire[x,y,z,50\[Mu]m,0,-6mm,6mm]+{Bx,By,Bz}; (* dimple wire *)*)
(*Return[Sqrt[VecField.VecField]]*)
(*]*)
(**)
(*ChipTrapVecField[x_,y_,z_,Ix_,Iy_,Bx_,By_,Bz_]:=Module[{VecField},*)
(*VecField=*)
(*    Ix*FatXwire[x,y,z,50\[Mu]m,0,-1.075mm,+1.075mm] (* main section of Z wire *)*)
(*+Ix*FatYwire[x,y,z,50\[Mu]m,-1.075 mm,-6mm,0mm] (* first leg of Z wire *)*)
(*+Ix*FatYwire[x,y,z,50\[Mu]m,1.075mm,0mm,6mm] (* second leg of Z wire *)*)
(*+Iy*FatYwire[x,y,z,50\[Mu]m,0,-6mm,6mm]+{Bx,By,Bz}; (* dimple wire *)*)
(*Return[VecField]*)
(*]*)


(* ::Input:: *)
(*(* {CLg1,CLd1,Bx1,By1,Bz1}   *)*)


(* ::Input:: *)
(*(* Plot3D[ChipTrapField[x,y,0.0005,3.2,-0.362,10.74 ,36,0.],{x,-10mm,10mm},{y,-2mm,2mm},PlotRange\[Rule]All,PlotPoints\[Rule]60,AxesLabel\[Rule]{"x","y","z"}]   *)*)


(* ::Subsection:: *)
(*Trap Position*)


(* ::Input:: *)
(*z0[Ilb_,Izb_,Ih_,Bx_,By_,Bz_]:=NMinimize[{ChipTrapField[x,y,z,Ilb,Izb,Ih,Bx,By,Bz],-.4 mm<x<.4mm,-.4mm<y<1.5mm,2500\[Mu]m>z>20\[Mu]m},{x,y,z}][[2]](* Returns the spatial coordinates {xmin, ymin, zmin} of the chip's magnetic field minimum. *)*)


(* ::Subsection:: *)
(*Trap Frequencies & Field/Vector Functions*)


(* ::Input:: *)
(*Dxx[x_,y_,z_,Ilb_,Izb_,Ih_,Bx_,By_,Bz_]:=D[10^-4 ChipTrapField[x,y,z,Ilb,Izb,Ih,Bx,By,Bz],{x,2}];*)
(*Dxy[x_,y_,z_,Ilb_,Izb_,Ih_,Bx_,By_,Bz_]:=D[10^-4 ChipTrapField[x,y,z,Ilb,Izb,Ih,Bx,By,Bz],x,y];*)
(*Dxz[x_,y_,z_,Ilb_,Izb_,Ih_,Bx_,By_,Bz_]:=D[10^-4 ChipTrapField[x,y,z,Ilb,Izb,Ih,Bx,By,Bz],x,z];*)
(*Dyy[x_,y_,z_,Ilb_,Izb_,Ih_,Bx_,By_,Bz_]:=D[10^-4 ChipTrapField[x,y,z,Ilb,Izb,Ih,Bx,By,Bz],{y,2}];*)
(*Dyz[x_,y_,z_,Ilb_,Izb_,Ih_,Bx_,By_,Bz_]:=D[10^-4 ChipTrapField[x,y,z,Ilb,Izb,Ih,Bx,By,Bz],y,z];*)
(*Dzz[x_,y_,z_,Ilb_,Izb_,Ih_,Bx_,By_,Bz_]:=D[10^-4 ChipTrapField[x,y,z,Ilb,Izb,Ih,Bx,By,Bz],{z,2}];*)
(*DMatrix[x_,y_,z_,Ilb_,Izb_,Ih_,Bx_,By_,Bz_]:=({*)
(* {Dxx[x,y,z,Ilb,Izb,Ih,Bx,By,Bz], Dxy[x,y,z,Ilb,Izb,Ih,Bx,By,Bz], Dxz[x,y,z,Ilb,Izb,Ih,Bx,By,Bz]},*)
(* {Dxy[x,y,z,Ilb,Izb,Ih,Bx,By,Bz], Dyy[x,y,z,Ilb,Izb,Ih,Bx,By,Bz], Dyz[x,y,z,Ilb,Izb,Ih,Bx,By,Bz]},*)
(* {Dxz[x,y,z,Ilb,Izb,Ih,Bx,By,Bz], Dyz[x,y,z,Ilb,Izb,Ih,Bx,By,Bz], Dzz[x,y,z,Ilb,Izb,Ih,Bx,By,Bz]}*)
(*});*)
(**)
(*(* The function ChipTrapFrequencies calculates the position z0 where the trap is centered. It does this using the values for the chip currents and bias fields. It assumes the trap is centered at x=0 and y=0 *)*)
(**)
(**)
(**)
(**)
(*ChipTrapFrequencies[Ilb_,Izb_,Ih_,Bx_,By_,Bz_]:= Module[*)
(*{x,y,z,DMatrixDiag,xmin,ymin,zmin,DMatrix0,e1,e2,e3},*)
(*{xmin,ymin,zmin}=z0[Ilb,Izb,Ih,Bx,By,Bz];*)
(*xmin=xmin[[2]];*)
(*ymin=ymin[[2]];*)
(*zmin=zmin[[2]];*)
(*DMatrix0=SchurDecomposition[DMatrix[x,y,z,Ilb,Izb,Ih,Bx,By,Bz]/.{x->xmin,y->ymin,z->zmin}];*)
(*DMatrixDiag=DMatrix0[[2]];*)
(*e1=DMatrix0[[1,1]];*)
(*e2=DMatrix0[[1,2]];*)
(*e3=DMatrix0[[1,3]];*)
(*Return[*)
(* {{\[Phi],(180/Pi)ArcTan[e1[[2]]/e1[[1]]]//Round,*)
(*\[Theta],(180/Pi)ArcCos[e1[[3]]/Sqrt[e1[[1]]^2+e1[[2]]^2+e1[[3]]^2]]//Round},*)
(**)
(*{\[Phi],(180/Pi)ArcTan[e2[[2]]/e2[[1]]]//Round,*)
(*\[Theta],(180/Pi)ArcCos[e2[[3]]/Sqrt[e2[[1]]^2+e2[[2]]^2+e2[[3]]^2]]//Round},*)
(**)
(*{\[Phi],(180/Pi)ArcTan[e3[[2]]/e3[[1]]]//Round,*)
(*\[Theta],(180/Pi)ArcCos[e3[[3]]/Sqrt[e3[[1]]^2+e3[[2]]^2+e3[[3]]^2]]//Round},*)
(**)
(**)
(*Diagonal[Sqrt[\[Mu]B Abs[DMatrixDiag]/mRb]/(2\[Pi]) ]}(* in Hz *)*)
(*]*)
(*]*)
(**)
(*ChipTrapFrequenciesOld[Ilb_,Izb_,Ih_,Bx_,By_,Bz_]:= Module[*)
(*{x,y,z,DMatrixDiag,xmin,ymin,zmin},*)
(*{xmin,ymin,zmin}=z0[Ilb,Izb,Ih,Bx,By,Bz];*)
(*xmin=xmin[[2]];*)
(*ymin=ymin[[2]];*)
(*zmin=zmin[[2]];*)
(*DMatrixDiag=Eigensystem[DMatrix[x,y,z,Ilb,Izb,Ih,Bx,By,Bz]/.{x->xmin,y->ymin,z->zmin}];*)
(*Return[*)
(* Sqrt[\[Mu]B Abs[DMatrixDiag[[1]]]/mRb]/(2\[Pi]) (* in Hz *)*)
(*]*)
(*]*)
(**)
(**)
(*BChipMag[x_, y_, z_] :=ChipTrapField[x, y, z, CurrL, CurrZ,CurrH, Bx1, By1, Bz1] Gauss;  *)
(*BChipMagC=Compile[{x,y,z},Evaluate[BChipMag[x,y,z]]]; *)
(*BChipMagC2[x_?NumericQ,y_?NumericQ,z_?NumericQ]:=BChipMagC[x,y,z];*)
(* *)
(*BChip[x_, y_, z_] :=   ChipTrapVecField[x, y, z, CurrL, CurrZ, CurrH,Bx1, By1, Bz1] Gauss;*)
(*BChipDirection[x_, y_, z_] := BChip[x, y, z]/BChipMag[x, y, z]*)
(*XCosine[x_,y_,z_]:=Sin[ArcCos[Dot[BChipDirection[x,y,z],{0,0,1}]]];    (* not necessarily relevant unless approximating *)*)
(**)
(*(*Bmin1=ChipTrapField[x1,y1,z1,CurrL,CurrZ,CurrH,Bx1,By1,Bz1 ]*)*)
(*(*B0 = BChipMag[x1,y1,z1];*)*)
(**)


(* ::Section:: *)
(*magnetic field from the rf loop (for z-dependence and directional concerns)*)


(* ::Input:: *)
(*i =1;*)
(*\[Beta][z_,z0_,a_]:=(z-z0)/a;*)
(*\[Alpha][r_,a_]:=r/a;*)
(*\[Gamma][z_,z0_,r_]:=(z-z0)/r;*)
(*B[a_]:=i*\[Mu]0/(2a);*)
(*Q[z_,z0_,r_,a_]:=(1+\[Alpha][r,a])^2+\[Beta][z,z0,a]^2;*)
(*d[z_,z0_,r_,a_]:=(4\[Alpha][r,a])/Q[z,z0,r,a];*)
(**)
(*Bz[z_,z0_,r_,a_]:=B[a]*(1/(\[Pi]*Sqrt[Q[z,z0,r,a]]))*((EllipticE[d[z,z0,r,a]])((1-\[Alpha][r,a]^2-\[Beta][z,z0,a]^2)/(Q[z,z0,r,a]-4\[Alpha][r,a]))+EllipticK[d[z,z0,r,a]])*)
(**)
(*Br[z_,z0_,r_,a_]:=B[a]*(\[Gamma][z,z0,r]/(\[Pi]*Sqrt[Q[z,z0,r,a]]))*((EllipticE[d[z,z0,r,a]])*((1+\[Alpha][r,a]^2+\[Beta][z,z0,a]^2)/(Q[z,z0,r,a]-4\[Alpha][r,a]))-EllipticK[d[z,z0,r,a]]) (* When on-axis, Br=0*)*)
(*Bmag[z_,z0_,r_,a_]:=Sqrt[(Bz[z,z0,r,a])^2+(Br[z,z0,r,a])^2] (*magnitude of total magnetic field*)*)
(**)
(*Btest[z_,z0_,a_]:=(\[Mu]0 i/2) a^2/(a^2 + (z-z0)^2)^1.5;*)
(*Plot[Bmag[z,0,1*^-10,.005]-Btest[z,0,.005],{z,0,.01},Frame->True]*)
(*Plot[(h /kb/1*^-9)(15000Bmag[z,LoopOriginZ,1*^-10,.005]/Bmag[z1,LoopOriginZ,1*^-10,.005] - 15000),{z,0.000660,.000860},Frame->True,Axes->False,PlotStyle->Thickness[.02]]*)


(* ::Input:: *)
(*Plot[(Bmag[z,LoopOriginZ,x1+.00001,.005]/Bmag[z1,LoopOriginZ,x1+.00001,.005] ),{z,-.010,.010},Frame->True,Axes->False,PlotStyle->Thickness[.01],GridLines->{{0,z1},{1.0,z1}}]*)


(* ::Input:: *)
(*LoopRadius = 1.5 5.0 mm; (* 5.0 default from SM2 *)*)
(*LoopOriginZ = -3.0 mm;*)
(**)


(* ::Input:: *)
(*RFUnitVec[x_,y_,z_]:={*)
(*Br[z,LoopOriginZ,Sqrt[x^2+y^2],LoopRadius] x/Sqrt[x^2+y^2],*)
(*Br[z,LoopOriginZ,Sqrt[x^2+y^2],LoopRadius] y/Sqrt[x^2+y^2] , *)
(*Bz[z,LoopOriginZ,Sqrt[x^2+y^2],LoopRadius]*)
(*}/Bmag[z,LoopOriginZ,Sqrt[x^2+y^2],LoopRadius]*)
(**)
(*XCosineAccurate[x_,y_,z_]:=Sin[ArcCos[Dot[BChipDirection[x,y,z],RFUnitVec[x,y,z]]]];  (* projection between local field and ideally-orthogonal rf polarization *)*)
(*GermanAngle[x_,y_,z_]:=ArcCos[Dot[BChipDirection[x,y,z],RFUnitVec[x,y,z]]];  (* projection between local field and ideally-orthogonal rf polarization *)*)
(*XCosineAccurateC=Compile[{x,y,z},Evaluate[XCosineAccurate[x,y,z]]];*)
(*XCosineAccurateC2[x_?NumericQ,y_?NumericQ,z_?NumericQ]:= XCosineAccurateC[x,y,z];*)
(**)


(* ::Section:: *)
(*magnetic field from the chip (ii)*)


(* ::Input:: *)
(*(* wacky *)*)
(*Ldec=0.5;*)
(*Zdec=1.1;*)
(*Hdec =1.0;*)
(**)
(*CurrL= Ldec    0.85A ;(* L wire current  0.85 default *) *)
(*CurrZ=Zdec     2.4A;  (* z wire current 2.40 default *)*)
(*CurrH=Hdec     2.3A;(* H wire current  2.3 default *)*)
(**)
(*fdec = 0.3;*)
(*Bx1=  fdec(-.22A)  40.625   ;*)
(*By1=  .4fdec (2.567A)  14.286 ;*)
(*Bz1=  fdec (.2 A ) 10.3675;*)
(**)
(**)
(**)
(**)
(*(* modified ZH *)*)
(*CurrL = 0.5 A ;(* L wire current  0.85 default *) *)
(*CurrZ =     2.3 A;  (* z wire current 2.40 default *)*)
(*CurrH =     2.7 A;(* H wire current  2.3 default *)*)
(**)
(*Bx1 = 3.2 (-.048 A)  40.625   ;*)
(*By1 = .6 (0.63 A)  14.286 ;*)
(*Bz1 = (-.1 A ) 10.3675;*)
(**)
(**)
(*(* Maren Mossman's 31 G trap *)*)
(*CurrL =     0. A ;(* L wire current  0.85 default *) *)
(*CurrZ =   3.2 A;  (* z wire current 2.40 default *)*)
(*CurrH =    1.0 A;(* H wire current  2.3 default *)*)
(*Bx1 =  (-.729 A)  40.625   ;*)
(*By1 =  (.765 A)  14.286 ;*)
(*Bz1 =   (0. A ) 10.3675;*)
(**)
(**)
(*(* ZH-b *)*)
(*CurrL = 0. A ;(* L wire current  0.85 default *) *)
(*CurrZ =     2.6 A;  (* z wire current 2.40 default *)*)
(*CurrH =     2.3 A;(* H wire current  2.3 default *)*)
(**)
(*Bx1 = (-.048 A)  40.625   ;*)
(*By1 = (0.63 A)  14.286 ;*)
(*Bz1 = (.0003 A ) (-10.3675);*)
(**)
(**)
(**)
(**)
(*(* ZH-b Cass *)  (* pretty nice, centered in window *)*)
(**)
(*CurrL = 0.0 A ;(* L wire current  0.85 default *) *)
(*CurrZ =     3.2A;  (* z wire current 2.40 default *)*)
(*CurrH =    1.3A;(* H wire current  2.3 default *)*)
(**)
(*Bx1 =(-.051 A)  40.625   ;*)
(*By1 =(0.195 A)  14.286 ;*)
(*Bz1 =1.0(.375 A ) (-10.3675);   (* sign disagreement here? *) *)
(**)
(*(* ZZH ZZH DO THIS DO THIS DO THIS?? *) *)
(**)
(**)
(**)
(*(* default  "Decompressed ZLH-b" *)*)
(*Ldec = 1.0;*)
(*Zdec = 1.0;*)
(*Hdec = 1.0;*)
(**)
(*CurrL = Ldec    0.85 A ;(* L wire current  0.85 default *) *)
(*CurrZ = Zdec     2.40 A;  (* z wire current 2.40 default *)*)
(*CurrH = Hdec     2.300 A;(* H wire current  2.3 default *)*)
(**)
(*fdec =0.4;*)
(*Bx1 = fdec (-.220 A) ( 40.625) 1.04 ;*)
(*By1 = fdec (2.567 A)  (14.286) .96 ;*)
(*Bz1 =    (-.150 A ) (-10.3675) 1.09;   (* claim that a negative current here means field in +z direction *)*)
(**)
(**)


(* ::Input:: *)
(*BChipMagC=Compile[{x,y,z},Evaluate[BChipMag[x,y,z]]];*)
(*BChipMagC2[x_?NumericQ,y_?NumericQ,z_?NumericQ]:=BChipMagC[x,y,z];*)
(*{x1,y1,z1}=z0[CurrL,CurrZ,CurrH,Bx1,By1,Bz1] //Chop*)
(*Print["x1 = ", Round[1000000 (x /. x1),.1], " \[Mu]m"]*)
(*Print["y1 = ", Round[1000000 (y /. y1),.1], " \[Mu]m"]*)
(*Print["z1 = ", Round[1000000 (z /. z1),.1], " \[Mu]m"]*)
(*x1=x1[[2]];*)
(*y1=y1[[2]];*)
(*z1=z1[[2]];*)
(*Bmin1=ChipTrapField[x1,y1,z1,CurrL,CurrZ,CurrH,Bx1,By1,Bz1 ];(* Magnitude of the field at the minimum in Gauss *)*)
(*B0 = BChipMag[x1,y1,z1]; (* As far as I can tell, the same as Bmin1*Gauss, so B0 is in Tesla *)*)
(**)
(**)
(*RFUnitVec[x_,y_,z_]:={*)
(*Br[z,LoopOriginZ,Sqrt[x^2+y^2],LoopRadius] x/Sqrt[x^2+y^2],*)
(*Br[z,LoopOriginZ,Sqrt[x^2+y^2],LoopRadius] y/Sqrt[x^2+y^2] , *)
(*Bz[z,LoopOriginZ,Sqrt[x^2+y^2],LoopRadius]*)
(*}/Bmag[z,LoopOriginZ,Sqrt[x^2+y^2],LoopRadius]*)
(**)
(*XCosineAccurate[x_,y_,z_]:=Sin[ArcCos[Dot[BChipDirection[x,y,z],RFUnitVec[x,y,z]]]];  (* projection between local field and ideally-orthogonal rf polarization *)*)
(*GermanAngle[x_,y_,z_]:=ArcCos[Dot[BChipDirection[x,y,z],RFUnitVec[x,y,z]]];  (* projection between local field and ideally-orthogonal rf polarization *)*)
(*XCosineAccurateC=Compile[{x,y,z},Evaluate[XCosineAccurate[x,y,z]]];*)
(*XCosineAccurateC2[x_?NumericQ,y_?NumericQ,z_?NumericQ]:= XCosineAccurateC[x,y,z];*)
(**)
(**)
(*(* MagFrac[x_,y_,z_]:=Cos[ArcSin[Br[z,LoopOriginZ,Sqrt[x^2+y^2],LoopRadius]/Bz[z,LoopOriginZ,Sqrt[x^2+y^2],LoopRadius]] ]Bmag[z,LoopOriginZ,Sqrt[x^2+y^2], LoopRadius]/Bmag[z1,LoopOriginZ,1*^-10, LoopRadius]; *)*)
(**)
(*MagFrac[x_,y_,z_]:=Bmag[z,LoopOriginZ,Sqrt[x^2+y^2], LoopRadius]/Bmag[z1,LoopOriginZ,1*^-10, LoopRadius]; (* Magnitude of the rf loop magnetic field at radius Sqrt[x^2+y^2] and height z, scaled by the magnitude of the same field evaluated at the trap minimum z coordinate and radius 1*^-10 (0.1 nm, effectively zero) *)*)
(*MagFracC=Compile[{x,y,z},Evaluate[MagFrac[x,y,z]]];*)
(*MagFracC2[x_?NumericQ,y_?NumericQ,z_?NumericQ]:=MagFracC[x,y,z];*)
(*MagFracSimple[x_,y_,z_]:=Bmag[z,LoopOriginZ,Sqrt[x^2+y^2], LoopRadius]/Bmag[z1,LoopOriginZ,1*^-10, LoopRadius]*)
(* *)
(**)


(* ::Input:: *)
(*Print["Bmin = ", NumberForm[Bmin1,3], " G"]*)
(*Print["trap bottom = "  ,\[CapitalDelta]guess = ((ZeemanShift[B0]//Differences //Mean)/1*^3 //Round)/1000.," MHz"]*)
(*Depth1=ChipTrapField[x1,y1,1.0,CurrL,CurrZ,CurrH, Bx1,By1,Bz1 ]-Bmin1; (*The comparison field is evaluated at z=1.0 is 1 m, essentially infinity.*)*)
(*Print["Depth = ", NumberForm[Depth1,3], " G"]*)
(*freqs1=ChipTrapFrequencies[CurrL,CurrZ,CurrH, Bx1,By1,Bz1 ];*)
(*Print["frequencies: ", NumberForm[freqs1,4], " Hz"]*)
(*Print["Aspect Ratio = ", NumberForm[Max[freqs1[[4]]]/Min[freqs1[[4]]],3]]*)
(*GraphicsGrid[{{*)
(*Plot[XCosineAccurateC2[x \[Mu]m,y1,z1]MagFracC2[x \[Mu]m,y1,z1],{x,x1/\[Mu]m-200,x1/\[Mu]m+200},Axes->False,Frame->True,GridLines->{{x1/\[Mu]m},{.9,1.0}},PlotRange->{0.85,1.01},FrameLabel->{"x"}],*)
(**)
(**)
(*Plot[XCosineAccurateC2[x1,y \[Mu]m,z1]MagFracC2[x1,y \[Mu]m,z1]*)
(*,{y,y1/\[Mu]m-200,y1/\[Mu]m+200},Axes->False,Frame->True,GridLines->{{y1/\[Mu]m},{.9,1.0}},PlotRange->{0.85,1.01},FrameLabel->{"y"}],*)
(*Plot[XCosineAccurateC2[x1,y1,z \[Mu]m]MagFracC2[x1,y1,z \[Mu]m],{z,z1/\[Mu]m-200,z1/\[Mu]m+200},AxesOrigin->{z1/\[Mu]m,0},Axes->False,Frame->True,GridLines->{{z1/\[Mu]m},{.9,1.0}},PlotRange->{.85,1.01},FrameLabel->{"z"}]}}]*)
(*100(XCosineAccurateC2[x1-100\[Mu]m,y1,z1]MagFracC2[x1-100\[Mu]m,y1,z1]-XCosineAccurateC2[x1+100 \[Mu]m,y1,z1]MagFracC2[x1+100 \[Mu]m,y1,z1])*)
(*100(XCosineAccurateC2[x1,y1-100 \[Mu]m,z1]MagFracC2[x1,y1-100 \[Mu]m,z1]-XCosineAccurateC2[x1,y1+100 \[Mu]m,z1]MagFracC2[x1,y1+100 \[Mu]m,z1])*)
(*100(XCosineAccurateC2[x1,y1,z1-100\[Mu]m]MagFracC2[x1,y1,z1-100\[Mu]m]-XCosineAccurateC2[x1,y1,z1+100\[Mu]m]MagFracC2[x1,y1,z1+100\[Mu]m])*)


(* ::Input:: *)
(**)


(* ::Input:: *)
(**)


(* ::Input:: *)
(*a=GraphicsGrid[{{*)
(*Plot1=Plot[ChipTrapField[x1,y1,z mm, CurrL, CurrZ,CurrH,Bx1,By1,Bz1],{z,0.010,1.5},*)
(*Frame->True,Axes->False,*)
(*PlotRange->{Bmin1-.5,Bmin1+0.5},*)
(*FrameLabel->{"Vertical Distance (mm)","Magnetic Field (G)"},*)
(*LabelStyle->Directive[FontFamily->"Arial",FontSize->10,Background->None],*)
(*FrameTicksStyle->Directive[FontSize->10,Background->None],*)
(*Background->White,GridLines->{{z1/mm},{}},*)
(*ImageSize->200*)
(*],*)
(*Plot2=Plot[{*)
(*ChipTrapField[x mm,y1,z1,CurrL, CurrZ,CurrH,Bx1,By1,Bz1],ChipTrapField[x1,x mm,z1,CurrL, CurrZ,CurrH,Bx1,By1,Bz1 ]},{x,-4.05,4.05},*)
(*PlotStyle->{Orange,Green},*)
(*Frame->True,Axes->False,*)
(*PlotRange->{Bmin1-.2,Bmin1+4.0},*)
(*FrameLabel->{"Transverse Distance (mm)","Magnetic Field (G)"},*)
(*LabelStyle->Directive[FontFamily->"Arial",FontSize->10,Background->None],*)
(*FrameTicksStyle->Directive[FontSize->10,Background->None],GridLines->{{x1/mm,y1/mm},{}},*)
(*Background->White,*)
(*ImageSize->200*)
(*],*)
(*ContourPlot[ChipTrapField[x mm,y mm,z1,CurrL, CurrZ,CurrH,Bx1,By1,Bz1],{x,-1,1},{y,-1,1},Contours->15,FrameLabel->{"X (mm)","Y (mm)"},PlotRange->{Bmin1-.5,Bmin1+4.5}],*)
(*ContourPlot[ChipTrapField[x mm,y1,z mm,CurrL, CurrZ,CurrH,Bx1,By1,Bz1],{x,-1,1},{z,0,2},Contours->15,FrameLabel->{"X (mm)","Z (mm)"},PlotRange->{Bmin1-.5,Bmin1+4.5}],*)
(*ContourPlot[ChipTrapField[x1,y mm,z mm,CurrL, CurrZ,CurrH,Bx1,By1,Bz1],{y,-1,1},{z,0,2},Contours->15,FrameLabel->{"Y (mm)","Z (mm)"},PlotRange->{Bmin1-.5,Bmin1+4.5}]*)
(*}}]*)
(**)


(* ::Section:: *)
(*trap potential*)


(* ::Subsection:: *)
(*Deviation from x of background dc field*)


(* ::Input:: *)
(*ContourPlot[XCosineAccurateC2[x/1000,y/1000,z1],{x,x1/mm-.5,x1/mm+.5},{y,y1/mm-.5,y1/mm+.5},Contours->Table[i,{i,1,.95,-.002}],PlotPoints->15,PlotRange->{.95,1},PlotLegends->BarLegend[All,LegendLabel->"inhom",LabelStyle->{Bold,Gray,16}],*)
(*Epilog->{Gray,Thick,Line[{{-1,1000y1},{1,1000y1}}],Gray,Thick,Line[{{1000x1,-1},{1000x1,1.0}}]},*)
(*LabelStyle->{Gray,Bold,16},FrameLabel->{"X [mm]","Y [mm]"}]*)
(**)
(*ContourPlot[XCosineAccurateC2[x1,y mm,z mm],{y,y1/mm-.5,y1/mm+.5},{z,0.1,1},Contours->Table[i,{i,1,.95,-.002}],PlotPoints->15,PlotRange->{.95,1},PlotLegends->BarLegend[All,LegendLabel->"inhom",LabelStyle->{Bold,Gray,16}],*)
(*Epilog->{Gray,Thick,Line[{{-1,1000z1},{1,1000z1}}],Gray,Thick,Line[{{1000y1,-1},{1000y1,1.0}}]},*)
(*LabelStyle->{Gray,Bold,16},FrameLabel->{"Y [mm]","Z [mm]"}]*)


(* ::Input:: *)
(*ContourPlot[BChipDirection[x mm,y mm,z1][[3]],{x,-.5,.5},{y,y1/mm-.5,y1/mm+.5},Contours->Table[i,{i,-.2,.2,.05}],PlotLegends->BarLegend[All,LegendLabel->"Z weight",LabelStyle->Directive[Brown,FontSize->14,Italic]],Epilog->{Gray,Thick,Line[{{-1,1000y1},{1,1000y1}}],Gray,Thick,Line[{{1000x1,-1},{1000x1,1.0}}]},LabelStyle->{Gray,Bold,16}]*)
(**)
(**)


(* ::Input:: *)
(**)


(* ::Input:: *)
(*GraphicsGrid[{{*)
(*Plot[XCosineAccurateC2[x1,y1,z \[Mu]m],{z,z1/\[Mu]m-1000/2,z1/\[Mu]m+1000/2},AxesOrigin->{z1/\[Mu]m,0},Axes->False,Frame->True,GridLines->{{z1/\[Mu]m},{.9,1.0}},PlotRange->{.85,1.01},FrameLabel->{"z"}],*)
(*Plot[XCosineAccurateC2[x \[Mu]m,y1,z1],{x,x1/\[Mu]m-1000/2,x1/\[Mu]m+1000/2},Axes->False,Frame->True,GridLines->{{x1/\[Mu]m},{.9,1.0}},PlotRange->{0.85,1.01},FrameLabel->{"x"}],*)
(*Plot[{XCosineAccurateC2[x1,y \[Mu]m,z1],*)
(*XCosine[x1,y \[Mu]m,z1]},{y,y1/\[Mu]m-1000/2,y1/\[Mu]m+1000/2},Axes->False,Frame->True,GridLines->{{y1/\[Mu]m},{.85,1.0}},PlotRange->{0.5,1.01},FrameLabel->{"y"}]}}]*)


(* ::Input:: *)
(* *)


(* ::Subsection:: *)
(*Definition of adiabatic potentials; rotating-frame + RWA*)
(*(this is equivalent to \[CapitalDelta] Fz + (\[CapitalOmega]/2) Fx   + Zeeman energies   (note Perrin/Garraway papers just use Subscript[\[CapitalOmega], 0] Fx)*)


(* ::Input:: *)
(*Clear[AdiabaticEnergiesChipC,AdiabaticEnergiesChipC2,AdiabaticEnergiesChipC2All]*)
(*AdiabaticEnergiesChipSlow[\[CapitalDelta]_,\[CapitalOmega]_,x_,y_,z_]:=Max[Eigenvalues[ ({*)
(* {2\[CapitalDelta], \[CapitalOmega]/2  , 0, 0, 0},*)
(* { \[CapitalOmega]/2 , \[CapitalDelta], Sqrt[3/2]\[CapitalOmega] /2 , 0, 0},*)
(* {0, Sqrt[3/2] \[CapitalOmega] /2 , 0,  Sqrt[3/2]\[CapitalOmega] /2 , 0},*)
(* {0, 0,  Sqrt[3/2]\[CapitalOmega] /2 , -\[CapitalDelta], \[CapitalOmega] /2 },*)
(* {0, 0, 0, \[CapitalOmega] /2 , -2\[CapitalDelta]}*)
(*})+({*)
(* {ZeemanShift[BChipMag[x,y,z]][[1]], 0, 0, 0, 0},*)
(* {0, ZeemanShift[BChipMag[x,y,z]][[2]], 0, 0, 0},*)
(* {0, 0, ZeemanShift[BChipMag[x,y,z]][[3]], 0, 0},*)
(* {0, 0, 0, ZeemanShift[BChipMag[x,y,z]][[4]], 0},*)
(* {0, 0, 0, 0, ZeemanShift[BChipMag[x,y,z]][[5]]}*)
(*})]];  *)
(*AdiabaticEnergiesChipC[\[CapitalDelta]_,\[CapitalOmega]_,x_,y_,z_]:=Max[Eigenvalues[ ({*)
(* {2\[CapitalDelta], \[CapitalOmega]/2  , 0, 0, 0},*)
(* { \[CapitalOmega]/2 , \[CapitalDelta], Sqrt[3/2]\[CapitalOmega] /2 , 0, 0},*)
(* {0, Sqrt[3/2] \[CapitalOmega] /2 , 0,  Sqrt[3/2]\[CapitalOmega] /2 , 0},*)
(* {0, 0,  Sqrt[3/2]\[CapitalOmega] /2 , -\[CapitalDelta], \[CapitalOmega] /2 },*)
(* {0, 0, 0, \[CapitalOmega] /2 , -2\[CapitalDelta]}*)
(*})+({*)
(* {ZeemanShiftC[BChipMagC2[x,y,z]][[1]], 0, 0, 0, 0},*)
(* {0, ZeemanShiftC[BChipMagC2[x,y,z]][[2]], 0, 0, 0},*)
(* {0, 0, ZeemanShiftC[BChipMagC2[x,y,z]][[3]], 0, 0},*)
(* {0, 0, 0, ZeemanShiftC[BChipMagC2[x,y,z]][[4]], 0},*)
(* {0, 0, 0, 0, ZeemanShiftC[BChipMagC2[x,y,z]][[5]]}*)
(*})]];  *)
(**)
(*AdiabaticEnergiesChipC2[\[CapitalDelta]_?NumericQ,\[CapitalOmega]_?NumericQ,x_?NumericQ,y_?NumericQ,z_?NumericQ]:=AdiabaticEnergiesChipC[\[CapitalDelta], \[CapitalOmega],x,y,z ];*)
(**)
(*AdiabaticEnergiesChipCAll[\[CapitalDelta]_,\[CapitalOmega]_,x_,y_,z_]:=Eigenvalues[ ({*)
(* {2\[CapitalDelta], \[CapitalOmega]/2  , 0, 0, 0},*)
(* { \[CapitalOmega]/2 , \[CapitalDelta], Sqrt[3/2]\[CapitalOmega] /2 , 0, 0},*)
(* {0, Sqrt[3/2] \[CapitalOmega] /2 , 0,  Sqrt[3/2]\[CapitalOmega] /2 , 0},*)
(* {0, 0,  Sqrt[3/2]\[CapitalOmega] /2 , -\[CapitalDelta], \[CapitalOmega] /2 },*)
(* {0, 0, 0, \[CapitalOmega] /2 , -2\[CapitalDelta]}*)
(*})+({*)
(* {ZeemanShiftC[BChipMagC2[x,y,z]][[1]], 0, 0, 0, 0},*)
(* {0, ZeemanShiftC[BChipMagC2[x,y,z]][[2]], 0, 0, 0},*)
(* {0, 0, ZeemanShiftC[BChipMagC2[x,y,z]][[3]], 0, 0},*)
(* {0, 0, 0, ZeemanShiftC[BChipMagC2[x,y,z]][[4]], 0},*)
(* {0, 0, 0, 0, ZeemanShiftC[BChipMagC2[x,y,z]][[5]]}*)
(*})];  (* +MicrowaveShift[x,y,z]   *)    *)
(**)
(*AdiabaticEnergiesChipC2All[\[CapitalDelta]_?NumericQ,\[CapitalOmega]_?NumericQ,x_?NumericQ,y_?NumericQ,z_?NumericQ]:=AdiabaticEnergiesChipCAll[\[CapitalDelta], \[CapitalOmega],x,y,z ];*)
(**)
(*AdiabaticVectorsChipC[\[CapitalDelta]_,\[CapitalOmega]_,x_,y_,z_]:=Eigenvectors[ ({*)
(* {2\[CapitalDelta], \[CapitalOmega]/2  , 0, 0, 0},*)
(* { \[CapitalOmega]/2 , \[CapitalDelta], Sqrt[3/2]\[CapitalOmega] /2 , 0, 0},*)
(* {0, Sqrt[3/2] \[CapitalOmega] /2 , 0,  Sqrt[3/2]\[CapitalOmega] /2 , 0},*)
(* {0, 0,  Sqrt[3/2]\[CapitalOmega] /2 , -\[CapitalDelta], \[CapitalOmega] /2 },*)
(* {0, 0, 0, \[CapitalOmega] /2 , -2\[CapitalDelta]}*)
(*})+({*)
(* {ZeemanShiftC[BChipMagC2[x,y,z]][[1]], 0, 0, 0, 0},*)
(* {0, ZeemanShiftC[BChipMagC2[x,y,z]][[2]], 0, 0, 0},*)
(* {0, 0, ZeemanShiftC[BChipMagC2[x,y,z]][[3]], 0, 0},*)
(* {0, 0, 0, ZeemanShiftC[BChipMagC2[x,y,z]][[4]], 0},*)
(* {0, 0, 0, 0, ZeemanShiftC[BChipMagC2[x,y,z]][[5]]}*)
(*})];  *)
(**)
(**)
(**)


(* ::Input:: *)
(*1000First@AbsoluteTiming@Table[AdiabaticEnergiesChipSlow[\[CapitalDelta]1,\[CapitalOmega]1,x1,y1,z1+zi],{zi,.0001,.0002,.00001}]*)
(*1000First@AbsoluteTiming@Table[AdiabaticEnergiesChipC[\[CapitalDelta]1,\[CapitalOmega]1,x1,y1,z1+zi],{zi,.0001,.0002,.00001}]*)
(*1000First@AbsoluteTiming@Table[AdiabaticEnergiesChipC2[\[CapitalDelta]1,\[CapitalOmega]1,x1,y1,z1+zi],{zi,.0001,.0002,.00001}]*)
(**)
(**)


(* ::Section:: *)
(*calculate some potentials!*)


(* ::Input:: *)
(*\[CapitalDelta]guess = (ZeemanShift[B0]//Differences)[[4]]*)


(* ::Input:: *)
(*\[CapitalDelta]1=\[CapitalDelta]guess+50*^3;*)
(**)
(*\[CapitalOmega]c =     1.0 16.983*^3;   (* rabi frequency *)  (* taken from German's current of like .02A or something, but with loop coplanar with chip *)*)
(*\[CapitalOmega]c =    5*^3;*)
(*Clear[testf];*)
(*testf[x_,y_,z_]:=AdiabaticEnergiesChipC2[\[CapitalDelta]1, \[CapitalOmega]c  XCosineAccurateC2[x,y,z] MagFracC2[x,y,z ]    ,x,y,z];*)
(*t= Table[{z,testf[x1,y1,z]},{z,z1-1.2 mm,z1+1.2mm,0.125*^-6}];*)
(*minloc= Position[t[[All,2]],Min[t[[All,2]]]][[1,1]];*)
(*zmin = t[[Position[t[[All,2]],Min[t[[All,2]]]][[1,1]],1]];*)
(*ShiftVal=AdiabaticEnergiesChipC2[\[CapitalDelta]1,\[CapitalOmega]c  XCosineAccurateC2[x1,y1,zmin]MagFracC2[x1,y1,zmin ],x1,y1,zmin];*)
(*testf[x1,y1,z1]nKPerHz;*)
(*Ububble[x_,y_,z_]:= testf[x,y,z]-ShiftVal;*)
(*Plot[Ububble[x1,y1,z],{z,z1-.0002,z1+.0002},PlotRange->{0,10000}];*)


(* ::Input:: *)
(*BoxSize =.3; (* mm *)*)


(* ::Input:: *)
(*GraphicsGrid[{{Plot[{*)
(*(-ShiftVal+AdiabaticEnergiesChipC2[\[CapitalDelta]1, \[CapitalOmega]c  ,x1,y1,z/1000-1*^-6]),*)
(*(-ShiftVal+ AdiabaticEnergiesChipC2[\[CapitalDelta]1, \[CapitalOmega]c XCosineAccurateC2[x1,y1,z/1000] MagFracC2[x1,y1,z mm],x1,y1,z mm])*)
(*},{z,1000z1-BoxSize/4,1000z1+BoxSize/4},PlotRange->{-100,250},PlotStyle->Thickness[.01],PlotPoints->300,FrameStyle->Directive[Black,12,FontFamily->"Century Gothic"],Axes->False,GridLines->{{1000z1},{0,21,-21,42,63,84,105}},GridLinesStyle->Dashed,FrameLabel->{"Z [mm]","Energy [Hz]"}],*)
(*Plot[{*)
(*(-ShiftVal+AdiabaticEnergiesChipC2[\[CapitalDelta]1, \[CapitalOmega]c  ,x1,y/1000-1*^-6,z1]),*)
(*(-ShiftVal+AdiabaticEnergiesChipC2[\[CapitalDelta]1, \[CapitalOmega]c   XCosineAccurateC2[x1,y/1000,z1]MagFracC2[x1,y mm,z1]  ,x1,y/1000,z1])},*)
(*{y,y1/mm-BoxSize/4,y1/mm+BoxSize/4},*)
(*PlotRange->{-100,250},PlotStyle->Thickness[.01],*)
(*FrameStyle->Directive[Black,12,FontFamily->"Century Gothic"],Axes->False,*)
(*GridLines->{{1000y1},{0,21,-21,42}},GridLinesStyle->Dashed,FrameLabel->{"Y (mm)","Energy (Hz)"}],*)
(*Plot[{*)
(*(-ShiftVal+AdiabaticEnergiesChipC2[\[CapitalDelta]1, \[CapitalOmega]c  ,x/1000-1*^-6,y1,z1]),*)
(*(-ShiftVal+1+AdiabaticEnergiesChipC2[\[CapitalDelta]1, \[CapitalOmega]c XCosineAccurateC2[x/1000,y1,z1]MagFracC2[x/1000,y1,z1] ,x/1000,y1,z1])},*)
(*{x,x1/mm-BoxSize/2, x1/mm+BoxSize/2},PlotRange->{-100,250},PlotPoints->200,PlotStyle->Thickness[.01],FrameStyle->Directive[Black,12,FontFamily->"Century Gothic"],Axes->False,GridLinesStyle->Dashed,GridLines->{{1000x1},{0,21,-21,42}},FrameLabel->{"X (mm)","Energy (Hz)"}]}},ImageSize->1300]*)


(* ::Input:: *)
(*ftight =150;*)
(*fweak = 50;*)
(*AtomNumber =200000;*)
(*fbar = (ftight  ftight fweak)^.33333;*)
(*abar= Sqrt[hbar/(mRb 2 \[Pi] fbar)];*)
(*\[Mu]= (hbar 2 \[Pi] fbar/2)(15 AtomNumber (100.4 .529177*^-10)/abar)^(2/5);*)
(*Print[\[Mu]nK = \[Mu] /kb/1*^-9 //Round , " nK"] *)
(*Print[\[Mu]Hz =\[Mu]nK 21 //Round, " Hz"] *)
(*Print["Tight TF radius = ", Round[1*^6 Sqrt[2\[Mu]/(mRb 4 \[Pi]^2 ftight^2)]], " \[Mu]m"]*)
(*Print["Loose TF radius = ", Round[1*^6 Sqrt[2\[Mu]/(mRb 4 \[Pi]^2 fweak^2)]], " \[Mu]m"]*)


(* ::Input:: *)
(*graining = .1*^-6;*)
(*t= Table[{z,testf[x1,y1,z]},{z,z1-.5 mm,z1+.001mm,graining}];*)
(*minloc= Position[t[[All,2]],Min[t[[All,2]]]][[1,1]];*)
(*zmin = t[[Position[t[[All,2]],Min[t[[All,2]]]][[1,1]],1]];*)
(*minval = t[[minloc,2]] h/kb/1*^-9;*)
(*Print[minval, " nK at location z = ",1000 zmin, " mm"]*)
(*Print["fz = ",fz = Sqrt[h (t[[minloc+1,2]]-2t[[minloc,2]]+t[[minloc-1,2]])/graining^2/mRb]/2/\[Pi], " Hz"]*)
(*Print["SHO minimum ", SHOnKz=h fz/kb/1*^-9/2, " nK, ", fz/2, " Hz"]*)
(*minval+SHOnKz //Round*)


(* ::Input:: *)
(*graining = .1*^-6;*)
(*t= Table[{z,testf[x1,y1,z]},{z,z1-.001 mm,z1+3.0mm,graining}];*)
(*minloc= Position[t[[All,2]],Min[t[[All,2]]]][[1,1]];*)
(*zmin = t[[Position[t[[All,2]],Min[t[[All,2]]]][[1,1]],1]];*)
(*minval = t[[minloc,2]] h/kb/1*^-9;*)
(*Print[minval, " nK at location z = ",1000 zmin, " mm"]*)
(*Print["fz = ",fz = Sqrt[h (t[[minloc+1,2]]-2t[[minloc,2]]+t[[minloc-1,2]])/graining^2/mRb]/2/\[Pi], " Hz"]*)
(*Print["SHO minimum ", SHOnKz=h fz/kb/1*^-9/2, " nK, ", fz/2, " Hz"]*)
(*minval+SHOnKz //Round*)


(* ::Input:: *)
(*ty= Table[{y,testf[x1,y,z1]},{y,y1-.001,y1+0.001,graining}];*)
(*minlocy= Position[ty[[All,2]],Min[ty[[All,2]]]][[1,1]];*)
(*ymin = ty[[Position[ty[[All,2]],Min[ty[[All,2]]]][[1,1]],1]];*)
(*minvaly = ty[[minlocy,2]] h /kb/1*^-9;*)
(*Print[minvaly, " nK at location y = ",1000 ymin, " mm"]*)
(*Print["fy = ",fy=Sqrt[h (ty[[minlocy+1,2]]-2ty[[minlocy,2]]+ty[[minlocy-1,2]])/graining^2/mRb]/2/\[Pi]]*)
(*Print["SHO minimum ", SHOnKy=h fy/kb/1*^-9/2, " nK, ", fy/2, " Hz"]*)
(*minvaly+SHOnKy //Round*)


(* ::Input:: *)
(*tx= Table[{x,testf[x,y1,z1]},{x,x1-.001,x1+0.001,graining}];*)
(*minlocx= Position[tx[[All,2]],Min[tx[[All,2]]]][[1,1]];*)
(*xmin = tx[[Position[tx[[All,2]],Min[tx[[All,2]]]][[1,1]],1]];*)
(*minvalx = tx[[minlocx,2]]h /kb/1*^-9;*)
(*Print[minvalx, " nK at location yx= ",1000 xmin, " mm"]*)
(*Print["fx = ",fx=Sqrt[h (tx[[minlocx+1,2]]-2tx[[minlocx,2]]+tx[[minlocx-1,2]])/graining^2/mRb]/2/\[Pi]]*)
(*Print["SHO minimum ", SHOnKx=h fx/kb/1*^-9/2, " nK, ", fx/2, " Hz"]*)
(*minvalx+ SHOnKx //Round*)


(* ::Input:: *)
(*\[Lambda] = 10064*^-9;*)
(**)


(* ::Input:: *)
(*a1= ContourPlot[0 3000 Sin[2 \[Pi] x mm/\[Lambda]]^2 1*^9(h/kb)+(-ShiftVal+AdiabaticEnergiesChipC2[\[CapitalDelta]1,\[CapitalOmega]c XCosineAccurateC2[x/1000,y/1000,z1] MagFracC2[x/1000,y/1000,z1]  ,x/1000,y/1000,z1]),*)
(*{x,1000x1-BoxSize/2,1000x1+BoxSize/2},{y,1000y1-BoxSize/4,1000y1+BoxSize/4},*)
(*PlotRange->{-500,1000},*)
(*AspectRatio->1/2,*)
(*Contours->Table[i,{i,-500,1000,100}],*)
(*PlotPoints->102,ImageSize->1000,*)
(*FrameLabel->{"X (mm)","Y (mm)"},*)
(*FrameStyle->Directive[Thick,Black,12,FontFamily->"Century Gothic"],*)
(*Axes->False,*)
(*Epilog->{Red,Thin,Line[{{1000x1-.2,1000y1},{1000x1+.2,1000y1}}],Red,Thin,Line[{{1000x1,1000y1-.21},{1000x1,1000y1+.2}}]}]  (*takes ~10s to generate *)*)


(* ::Input:: *)
(*\[AliasDelimiter]*)


(* ::Input:: *)
(*ContourPlot[nKPerHz(-ShiftVal+AdiabaticEnergiesChipC2[\[CapitalDelta]1, \[CapitalOmega]c  XCosineAccurateC2[x/1000,y1,z/1000] MagFracC2[x/1000,y1,z/1000],x/1000,y1,z/1000]),{x,1000x1-BoxSize/2,1000x1+BoxSize/2},*)
(*{z,1000z1-BoxSize/4,1000z1+BoxSize/4},*)
(*PlotRange->{-100,200},ImageSize->1000,*)
(*Contours->Table[i,{i,-100,200,10}],PlotPoints->140,*)
(*FrameLabel->{"X (mm)","Z (mm)"},*)
(*FrameStyle->Directive[Thick,Black,12,FontFamily->"Century Gothic"],*)
(*Axes->False,AspectRatio->1/2,*)
(*Epilog->{Red,Thickness[.0005],Line[{{-.2,1000z1},{.2,1000z1}}],Red,Thickness[.0005],Line[{{1000x1,.2},{1000x1,1.0}}]}]  (*takes ~10s to generate *)   (* GridLines\[Rule]{Table[i,{i,x1/mm-.08,x1/mm+.08,.0045}],Table[i,{i,z1/mm-.04,z1/mm+.04,.0045}]} *)*)


(* ::Input:: *)
(*a1= ContourPlot[nKPerHz(-ShiftVal+AdiabaticEnergiesChipC2[\[CapitalDelta]1, \[CapitalOmega]c  XCosineAccurateC2[x1,y/1000,z/1000] MagFracC2[x1,y/1000,z/1000],x1,y/1000,z/1000]),{y,1000y1-BoxSize/4,1000y1+BoxSize/4},*)
(*{z,1000z1-BoxSize/4,1000z1+BoxSize/4},PlotRange->{-100,200},*)
(*Contours->Table[i,{i,-100,200,20}],PlotPoints->40,*)
(*AspectRatio->1,*)
(*ImageSize->500,*)
(*FrameLabel->{"Y (mm)","Z (mm)"},*)
(*FrameStyle->Directive[Thick,Black,12,FontFamily->"Century Gothic"],*)
(*Axes->False,Epilog->{Red,Thin,Line[{{-.2,1000z1},{.1,1000z1}}],Red,Thin,Line[{{1000y1,.4},{1000y1,1.0}}]}]  (*takes ~10s to generate *)*)


(* ::Input:: *)
(**)


(* ::Input:: *)
(*Print["z1 = ", Round[1*^6 z1], " microns"]*)


(* ::Input:: *)
(* \[CapitalDelta]1= 1.969*^6;*)
(*\[CapitalDelta]1 =1.97*^6; *)
(*\[CapitalDelta]1 = 3.8935*^6;*)
(*\[CapitalDelta]1 = 3.897*^6;*)
(*\[CapitalDelta]1 =3.909036*^6;*)
(*\[CapitalDelta]1= 1.786*^6;*)
(*\[CapitalDelta]1=2.647*^6;*)
(*\[CapitalDelta]1=1.350*^6;*)
(*\[CapitalDelta]1= 1.375*^6;*)
(*\[CapitalDelta]1=2.540*^6+ 40*^3;*)
(*\[CapitalDelta]1=2.500*^6+ 0*^3;*)
(**)
(*\[CapitalDelta]1=3.728*^6;*)
(**)
(*\[CapitalDelta]1=1.970*^6;*)
(*\[CapitalDelta]1=1.970*^6+ 40*^3;*)
(**)
(*\[CapitalDelta]1=\[CapitalDelta]guess+30*^3;*)
(**)
(**)
(**)
(*\[CapitalOmega]c = .25   16.983*^3;   (* rabi frequency *)  (* taken from German's current of like .02A or something, but with loop coplanar with chip *)*)
(*\[CapitalOmega]c =5*^3;(* rabi frequency *)*)
(**)


(* ::Input:: *)
(**)


(* ::Section:: *)
(*Test*)


(* ::Input:: *)
(*TestBECPotential[x_,y_,z_,\[Omega]_]:= (1/2) (mRb/h) \[Omega]^2 (x^2+y^2+z^2)*)


(* ::Input:: *)
(*fTest= 100;*)


(* ::Input:: *)
(*potential0 = Table[TestBECPotential[x,y,z,2Pi fTest],*)
(*{z,-CubeSize/4,+CubeSize/4,DataFileGraining},*)
(*{y,-CubeSize/4,+CubeSize/4,DataFileGraining},*)
(*{x,-CubeSize/2,+CubeSize/2,DataFileGraining}];*)


(* ::Input:: *)
(*Dimensions[potential0]*)


(* ::Input:: *)
(*potential0[0,0,z1-CubeSize/4,628]*)


(* ::Input:: *)
(*ListPlot[potential0[[51,;;,101]]]*)


(* ::Input:: *)
(*Plot[TestBECPotential[0,0,x,2 Pi 100],{x,-.001,.001}]*)


(* ::Input:: *)
(*potential0a=Flatten[potential0,1];*)
(*Dimensions[potential0a]*)
(*FileString0=StringJoin["TestPotential_",ToString[1000DataFileGraining/\[Mu]m//Round],"u_",ToString[fTest //Round],"Hz",".csv"]*)
(*"TestPotential_250u_100Hz.csv"*)


(* ::Input:: *)
(*Export[FileString0,potential0a]*)


(* ::Input:: *)
(*CenterPoint=Length[potential0]/2//Ceiling*)


(* ::Section:: *)
(*Real ones *)


(* ::Input:: *)
(*PotentialType ="Trap2_";*)
(*PotentialType ="Trap1_";*)
(*PotentialType ="Trap4_";*)


(* ::Input:: *)
(*t= Table[{z,testf[x1,y1,z]},{z,.2 mm,z1+20 \[Mu]m,1*^-6}];*)
(*minloc= Position[t[[All,2]],Min[t[[All,2]]]][[1,1]];*)
(*zmin = t[[minloc,1]];*)
(*ShiftVal=AdiabaticEnergiesChipC2[\[CapitalDelta]1,\[CapitalOmega]c  XCosineAccurateC2[x1,y1,zmin]MagFracC2[x1,y1,zmin ],x1,y1,zmin]*)
(**)
(*CubeSize= 100\[Mu]m;*)
(*CubeSize= 50\[Mu]m;*)
(*CubeSize= 350\[Mu]m;*)
(*CubeSize= 150\[Mu]m;*)
(*CubeSize= 400\[Mu]m;*)
(*CubeSize= 300\[Mu]m;*)
(**)
(*DataFileGraining = 0.5\[Mu]m;*)
(*DataFileGraining = 0.8\[Mu]m;*)
(*DataFileGraining = 1.0\[Mu]m;*)


(* ::Input:: *)
(*Parallelize[potential1=-ShiftVal+Table[AdiabaticEnergiesChipC2[\[CapitalDelta]1, \[CapitalOmega]c,x,y,z],*)
(*{z,z1-CubeSize/4,z1+CubeSize/4,DataFileGraining},*)
(*{y,y1-CubeSize/4,y1+CubeSize/4,DataFileGraining},*)
(*{x,x1-CubeSize/2,x1+CubeSize/2,DataFileGraining}];] //AbsoluteTiming*)


(* ::Input:: *)
(*Dimensions[potential1]*)


(* ::Input:: *)
(*potential1a=Flatten[potential1,1];*)
(*Dimensions[potential1a]*)


(* ::Input:: *)
(*FileString1=StringJoin["CALpotential_",PotentialType,ToString[1000 DataFileGraining/\[Mu]m//Round],"nm_d",ToString[\[CapitalDelta]1/1*^3 //Round],"_o",ToString[\[CapitalOmega]c//Round],"_hom.csv"]*)


(* ::Input:: *)
(*Parallelize[potential2=-ShiftVal+Table[AdiabaticEnergiesChipC2[\[CapitalDelta]1, \[CapitalOmega]c  XCosineAccurateC2[x,y,z]    ,x,y,z],*)
(*{z,z1-CubeSize/4,z1+CubeSize/4,DataFileGraining},*)
(*{y,y1-CubeSize/4,y1+CubeSize/4,DataFileGraining},*)
(*{x,x1-CubeSize/2,x1+CubeSize/2,DataFileGraining}];]*)
(*Dimensions[potential2]*)
(*potential2a=Flatten[potential2,1];*)
(*Dimensions[potential2a]*)


(* ::Input:: *)
(*FileString2=StringJoin["CALpotential_",PotentialType,ToString[1000 DataFileGraining/\[Mu]m//Round],"nm_d",ToString[\[CapitalDelta]1/1*^3//Round],"_o",ToString[\[CapitalOmega]c//Round],"_inhom1.csv"]*)


(* ::Input:: *)
(*Parallelize[potential3=-ShiftVal+Table[AdiabaticEnergiesChipC2[\[CapitalDelta]1, \[CapitalOmega]c  XCosineAccurateC2[x,y,z] MagFracC2[x,y,z ]   ,x,y,z],*)
(*{z,z1-CubeSize/4,z1+CubeSize/4,DataFileGraining},*)
(*{y,y1-CubeSize/4,y1+CubeSize/4,DataFileGraining},*)
(*{x,x1-CubeSize/2,x1+CubeSize/2,DataFileGraining}];]*)
(*Dimensions[potential3]*)
(*potential3a=Flatten[potential3,1];*)
(*Dimensions[potential3a]*)


(* ::Input:: *)
(*FileString3=StringJoin["CALpotential_",PotentialType,ToString[1000DataFileGraining/\[Mu]m//Round],"nm_d",ToString[\[CapitalDelta]1/1*^3 //Round],"_o",ToString[\[CapitalOmega]c//Round],"_inhom2.csv"]*)


(* ::Input:: *)
(*4+4*)


(* ::Input:: *)
(*Directory[]*)


(* ::Input:: *)
(*SetDirectory["/Users/nlundbla/Documents"];*)


(* ::Input:: *)
(*(* SetDirectory["/Volumes/GoogleDrive/My Drive/Mathematica Files/NASA CAL/potentials"] *)*)


(* ::Input:: *)
(**)


(* ::Input:: *)
(*Export[FileString3,potential3a]*)


(* ::Input:: *)
(*CopyFile["CALpotential_Trap2_1000nm_d2010_o5000_inhom2.csv","/Volumes/GoogleDrive/My Drive/Mathematica Files/NASA CAL/potentials/CALpotential_Trap2_1000nm_d2010_o5000_inhom2.csv"];*)


(* ::Input:: *)
(*DeleteFile["CALpotential_Trap2_1000nm_d2010_o5000_inhom2.csv"];*)


(* ::Input:: *)
(*Export[FileString1,potential1a]*)
(*Export[FileString2,potential2a]*)


(* ::Input:: *)
(*CenterPoint=Length[potential3]/2//Ceiling*)


(* ::Input:: *)
(*ListPlot[(potential3[[;;,CenterPoint,2CenterPoint]]),PlotRange->{-100,500},PlotStyle->{Red,PointSize[.02]},Joined->True,Mesh->All,  Frame->True,Axes->False,FrameLabel->{"Z"}]*)


(* ::Input:: *)
(*\[AliasDelimiter]*)


(* ::Input:: *)
(*Show[*)
(*ListPlot[(potential1[[;;,CenterPoint,2 CenterPoint]]),PlotRange->{-110,300},PlotStyle->{PointSize[.02],Blue},Joined->True,Frame->True,Axes->False,FrameLabel->{"Z (point number)","Energy (Hz)",StringJoin[ToString[DataFileGraining/\[Mu]m]," \[Mu]m graining"]},FrameStyle->Directive[14,FontFamily->"Century Gothic"]],*)
(*ListPlot[(potential2[[;;,CenterPoint,2CenterPoint]]),PlotRange->{-110,300},PlotStyle->{PointSize[.02],Gray},Joined->False,Frame->True,Axes->False,FrameLabel->{"Z (point number)","Energy (Hz)",StringJoin[ToString[DataFileGraining/\[Mu]m]," \[Mu]m graining"]},FrameStyle->Directive[14,FontFamily->"Century Gothic"]],*)
(*ListPlot[(potential3[[;;,CenterPoint,2CenterPoint]]),PlotRange->{-110,300},PlotStyle->{Red,PointSize[.02]},Joined->True,Frame->True,Axes->False,FrameLabel->{"Z"}]]*)
(*Show[ListPlot[(potential1[[CenterPoint,;;,2CenterPoint]]),PlotRange->{-110,300},PlotStyle->PointSize[.02],Joined->True,Frame->True,Axes->False,FrameLabel->{"Y (point number)", "Energy (Hz)",StringJoin[ToString[DataFileGraining/\[Mu]m]," \[Mu]m graining"]},FrameStyle->Directive[14,FontFamily->"Century Gothic"]],*)
(*ListPlot[(potential2[[CenterPoint,;;,2CenterPoint]]),PlotRange->{-110,300},PlotStyle->PointSize[.02],Joined->False,Frame->True,Axes->False]]*)
(*Show[ListPlot[(potential1[[CenterPoint,CenterPoint,;;]]),PlotRange->{-110,300},PlotStyle->PointSize[.02],Joined->True,Frame->True,Axes->False,FrameStyle->Directive[14,FontFamily->"Century Gothic"],FrameLabel->{"X (point number)", "Energy (Hz)",StringJoin[ToString[DataFileGraining/\[Mu]m]," \[Mu]m graining"]}],*)
(*ListPlot[(potential2[[CenterPoint,CenterPoint,;;]]),PlotRange->{-110,300},PlotStyle->PointSize[.02],Joined->False,Frame->True,Axes->False,FrameLabel->{"X"}]]*)


(* ::Input:: *)
(*Manipulate[ListContourPlot[nKPerHz potential1[[i]],PlotRange->{-10,50},Contours->10],{i,1,Length[potential1],1}]*)


(* ::Subsection:: *)
(*Look at all levels; motivated by some E. Elliott concerns?*)


(* ::Input:: *)
(*c=Plot[(-ShiftVal+Sort[AdiabaticEnergiesChipC2All[\[CapitalDelta]guess+250000,    10\[CapitalOmega]c   ,x1,y1,z/1000]])/1*^6,*)
(*{z,1000z1-.3,1000z1+.4},*)
(*PlotRange->{-1,1},*)
(*PlotStyle->Thickness[.01],*)
(*AspectRatio->2,*)
(*Axes->False,*)
(*FrameStyle->Directive[Thickness[.01],White,28,FontFamily->"Century Gothic"],*)
(*FrameLabel->{"Z [mm]","Energy [MHz]"}]*)


(* ::Input:: *)
(*Graphics[{{{}, {}, {RGBColor[0.368417, 0.506779, 0.709798], AbsoluteThickness[1.6], Opacity[1.], Dashing[{Small, Small}], Line[CompressedData["*)
(*1:eJwV1nk41NsbAHAqS1m/Q7YQkWXcVPYib5KlSJEiUlmyJdpLaSEVsiVk6aKU*)
(*CAkRSvWqpFwkLXIrjDlfTJuuUlL5nd9f83yeeeaZc971aPpFuG2dIiQkJC4s*)
(*JPT/T83aaUqt6TxIvf0wP7hPH7v/LONvy+ABb3lK0vNufUx1iL4umcmDx05P*)
(*ApZ16qPQ69+OLud4ECYyrUOrSR/7JsYiO7N5IDqekvy7UB/zbIb/fZXHgxn6*)
(*9jmSwfqo2taWzy/mgfEPE3Luix4q8jN1/9zmwW6nlbbeM/Rw21TR7rQhHkhU*)
(*yBy4aqiDwifrjZYzA2DaeQavn9HG5JFkE/1FA9B/brNxhLIWHnC2eRURMAA/*)
(*Oqp/5BZo4mUJC+2uxAFIqrJYfNlHA+ffluBk1Q1A5friZyut1LHCXfhK6sAA*)
(*pNumN4qJqOKuNZbsZQk+FF56Hyelp4JpS9yaVc35sEZfrVLWSwm/JZWvub6Z*)
(*D0rRjuWctwro0syN2X+KD+q8/KVLMmaiyEise0EVH2xz1iwT8pdHi9D9oTbV*)
(*fDCdanx0aJM8hvFDjvGo0271RHR5yePzbpcy7Ro+cJV+hla6yeMlVJpWcpMP*)
(*5k//a0xaJo/Lz5ZVV97mQ7jCpZhHc+Qxxuw5534zHzgGm4kVkcM/UVqdpIcP*)
(*G9a3/FbeJYc/QrO3p//LB+WoPQV+4XL4xVNmhu0bPnTX5K69FiqHfJOJZQVv*)
(*+WAWEz7s4i+Hjz88u+HVx4eJodqHN9zlMH1jTFYH4cOFi9YvOBZyyLXq31w/*)
(*wofXTkGj8sJyqM31+BX0hQ8eL8xv3vnNQTWltiyF//gQuFg7attPDsp+revc*)
(*PUrvuydArH2Ug99KU20Nx+h9GWmFmywH781aqls4wYeHBpuLldo4uG4i71Oi*)
(*KIGJiEZbhfMc/LSjcoOFGIHodVKK87I5GMfefzBA/ULkyT37TA42dA7lLJ5O*)
(*YP60uoyYVA6qFxs5DEkQuM8vtVA9wcEh9+Z8W4bAynyV3y/DORh17eOan7MI*)
(*bGjc7hq0nIMztYVuX1Yl4Nz1SrbbhoPXsjm6rmoEFCbnZDkBB/tjzX9fUSdw*)
(*/UXCr8WLOWjvHV2yTpPA8XmDMpYLOCgjPnNKpQ6BLh9m4q4qBy/6WlUHLSQg*)
(*YuhZ8/o7gy1D31PFjAiY1xtXtXxj8FNEdfgVapnl56UaRhm0PMLlDhoTeLUv*)
(*913hZwaf5yhdCDQjYLNcpPfsIIOiz78mb7UkEHVolhh5xWCofXmovx2Ba0vc*)
(*fFc0MJjaFuw41Z6AuM6myON1DNa6a+sUUh+8Z8S/W8vgVP/cfp4DAVXBnetQ*)
(*zeD5o/GefisJZNgpz/IuY7C9bqu972oCvx1zeEL5DC40UJ+zeQOBq4fXlYqc*)
(*ZFBVx+ekpBeNb9j0dSGxDIprnhfUU6vkppd1xDDYp6BSLb+RQHKdq/+lowwm*)
(*T1FY/mQTgU57N972SAY/vJYKNA0goH2ovfHYdga7nzs/4VHX9rOSMmEMPug4*)
(*bZi6lUBRk8+UglAGcx9O/y4IJLCUE//ucRCDKytF4gpCCHTnNbss8WOwOO53*)
(*iUQEgdhLEUUXPRhMP24lXU/t/Piglvd6Bo8dObQrcAcBN60IUFjHoMee8cW4*)
(*k8D7DDO3dDcazy3fWvftIbBPyuJlxSoG/c0/fuyPJPC15J/P/ssZVGffLKyL*)
(*JfBtxiq9RmMGz/33QNzrBIEvzWHPuo0YlJ0s652gln+uWje2kEFhpcNJcIrm*)
(*V7jMZNECBvkr1Iab4wmssR0f7P6LwavlPgUvkun5S0d4MToMajXY7d+fQsDQ*)
(*qV+paS7NR/M8F+VUAh2vvWOnUif1/p7YeIbGM2D7z0QtBncweR78swRK26I8*)
(*GzQYNNv7Tno0i8CvJZpxR2YxWBHdTNKzCVwoPjfcp8KgXvK122Y5BPb7Zhy0*)
(*o1a+ciT0YC6BGJ8i/ZnKDP7qVm8WzqPnP5JX2a7A4F4i+nchtfbr9thl1J++*)
(*fNptl09gtt/J2LqZDPbOuKsZX0AA30qIl8oz2GS1+bBsIYH1ll/lr3Jo/a5w*)
(*cK+i9rjMs5lPfWPdfAP3S7ReDm/IqmUYvBw+2X3uMoHATN97rbIMxhXkm8wu*)
(*JmD92fc/GRkGhcpPSSC1ufgs3yJpBiPrI3h+JQS0KjaNWVOHPoPUoqsERorE*)
(*zu6TYnDVtL7388oJOOWHJExKMJgY67TiLbU3u707n/rJtJtFidcIpC1cXbKM*)
(*2l4k2fd9BYHbX5s6U2YwGHti/E7OdQJtZX56i6mbRLaqrqwk4Bo/PslOZ9Ba*)
(*1OpVcRWBnx06Cxypo05eMfGsJrAi58mpX+IMNojKpYndILBl+OimampzMYFz*)
(*YA0Bh/WLT+lRLxDPatKqIzC8qqRugRiD4XFTNbqoN2LGxA9RBsvEIw7H1NP8*)
(*LH5Sf59af7q9RX8DAf1Nc4u2UAfHV2ak3qLzQ9+ry4i6aLraKNwmIPvzS6QY*)
(*9ZwZX8vzGgm4RAQtrBNhcEvCZgmXOwRajdfapFPnzWgN/k3NmWxs2UX9JsGs*)
(*uewunX875z9aSz1L4qLWxnsE/uYaWplTe52WipZAAmbbbHTVqLMkIt81UNvs*)
(*HjklQv3yNN8ytInA0MUmn5FpDMpLrslWvk/j3WBd/JbaLfHWWAt1y/j7wDbq*)
(*VEld9wMPCPgIu2XfpW5PTKvUfUjz9eW79Q1qKak/0q+oHwwHeJRSOyeFhJ1s*)
(*pvFO0OBdok6QevHY9BGtvxeV7wqoW5KW6hLqkOIC53xqUemy2PQWAlJkt8H/*)
(*v1+erMizfUzP61R9sJA6Rvo4jFIvsmQXlVDfS/50/uITAgtN04Mrqf9Ie/10*)
(*bSXgW79c9Da1VcpDD+F/CEwJPsp5TH1QZmHNdWqX/tbEbuq6lPOcLW20f05U*)
(*7hFQf5cR3yHTTqBXvu7xH2qz1N1td6izVwednknjtUe2lxveQWAsw77ekLoq*)
(*dWWc2lMCJkNv3VZSj8jWkn+o00RrPIKpDc9o2kZ10nl1Zu2jOOowJqnA4BmB*)
(*m442F0qph5gA74QuOs/VuWk/qHXSOuoWPScQ8LdJ8RxaDwEcS4Vh6qmCcp3V*)
(*1P0cTqfDS7ovkyS9K6g1zh42/E49EissO0C9SW74dNGr/+f7hIEyrc8euXv2*)
(*Iq8J7J67IT2Rum5Wy65K6uLcU40t1JlaT/N8eghUlTqZitH6djPuG6v5l8C2*)
(*nnbp09RP3ISuBL4jcO+gt8812i/FXuJdnF4C/zo8/fSL+qSf7OQd6vnMmtZV*)
(*tN+W7dLwUOyn+Y8s8x+jvnVmqVjLAIFciX0i/pIM5mQ7Gu/hE9ipNcC7T33g*)
(*wprNGoSAUs4zMV3a/yaVW24eYGk+5+7R+Upd9vRYkP4wvc+b4KsldJ6cl8FH*)
(*CZ/oflLbGhotR/Op+HjU7DMBtQ+yp0Xp/PKc3Tl7gLrqqNGHJGr5+f37Lb8Q*)
(*UDRTCC+k8y7RRVjvwyiBhhlMwLAi7f8km7hV47Qfk+Jq+1Rpv2SsuDFOfUV+*)
(*sCRejUGLv137Lv8ksGqw9qWJOoNfy3wt/kwQ2L5a0HNmNs3nP9FD1/4Q+G/f*)
(*lujAOQz6SDQ5yk5jYap9MT9Sj9a39u7B69R3VK12W+jT+1lrn3QVYWEn3/P9*)
(*D+oZO0/eTxNlwdaxKfOoAd3vL1daz5zOgt0/4U8LDRmUvthlrCLNQvlGyWMO*)
(*prTeLYi6thILbpLpnuO2DBq4ZTY+oK68vCjkK91vmdscNm5VZmHEStPzix09*)
(*X15JdpEK/X/RNR0jDgx9bYbL66uxcNPYW1nUmcGdHWPTDeew0Pu8pi3enc6f*)
(*QPFv5n+xMNvY0W40kNbDqJUKS63yJuySbTCDx4/thPR5LLR0ntPLDKH7MKcn*)
(*fsSQhXw7yzwbuu+LOsrUSxay8AvWGlXtpOdb5OqoYs5Ctf3dnPEoen/JnNxf*)
(*NiywrNl69Qxa39nt964uY0Fpj+6hqkwGM3Smsp62LJQKT7vpmMXg2NKwBTXL*)
(*WYjSuLfzUC6t373WD7c7sJBiLTw4foH2dy/v0ztnFvwMysO9Khi0qzJYhh4s*)
(*6LWw/KJWBqe4Tu/x92ThVtXidp82Gr/P7E7RDSzMC244rNBBfz/v4gUnLxb6*)
(*a7rmJT1j0KhYSfjlRhZcnFJaUl7T90KeyD2BLwsNe1dnD9P32o/43iXyYSw8*)
(*ZWuNPopw8Krv2UVBx1h4uz65RsOBg+JxUgWi0SwoHlDLslzBwa3XTokWUb/m*)
(*Nih7OnFQY+JQFz+Gxse+40fGag5mpgds9zvBwo1TrmpzPTkY/cj0gk8CCwd6*)
(*Zt5MDeGg57xucfd0Fnp+mQpykjgoOq7avbSYBR0mZVVIDwfvRh9XjOpioV5I*)
(*9JhMphze2m4o/HyCBe2K4ZIxH3mUd6o9naQ7CE6CLyNz18xEf9ktjQfdBqEm*)
(*uSvPfr0CfrNwyY49OAjzTSbZZZsVke+mrDByeRBGyyf/FJ1VQoWneksOtA9C*)
(*WtKdqUrNymht6iVhMjYI2Pxj94sps/DB6eCDrppD4O54s758myom2t06e3rF*)
(*EHw7c3zHtlY1rBoRrNLdOwRLPFNlJD1no8rkpqrev4fgUpR5xtA2DTzw7Wtj*)
(*68MhKOxZqd8/TxNN3gaFKn8ZAkPDQ1neonPQSG82HlcehiPJ0tUVL+ZgckB1*)
(*3Wq7YRiYtJpXfksL++JCPFbvGIbYDa8Xhl3Uxr2yAQXbsobhLr6IrT88F4Pi*)
(*LROG7w+DUPqeyeQIHTy/1UM99sMwbPz0e36buy4+0s/Y4CYvgD+VVVeOWOjh*)
(*6t4K0xgQgGhW6vVTRvqo8kP6dnuQAGQ7eIf91LnoSoLLY4IF4DTlRFvsHC7G*)
(*PWvKMwsRANvU63hFh4vfy/ZF54UKQMcqpOmDIRef+76zD98uAM/kPXcigYsp*)
(*reWdUrsFkPO26VHuFi5Oy3cedD4igK66sYTJi1y0TCzqFjoqAD84oqd7hYu7*)
(*IoWe3KB+8Ez5s0spF/vX3ihTjRbAyNFF3/OquXhHXHXXh+MC2Fr4YmTpAy4e*)
(*2PX+1+l4Afz13m9/IuFixWa7T5BAz/fXrvO1w1xknfN7R6kNS1cO933k4jrd*)
(*tU3eiQLY9HHaT9MxLhq9aThlkCKAske+3/pFDTD0sXxkL3XAx6j1UhIGeKE2*)
(*PPRsqgCS8hvfWcgYoOyZOasmzghAbsWmgFRFA3Q4EmVdkSaAkNQM39uzDPDI*)
(*tpfz/c8KQEP7womh2QZY67lAUzGdxudS2FN5bQP8aJfAaaU+2TdgY6NngP8D*)
(*sbcE7A==*)
(*"]], Line[CompressedData["*)
(*1:eJwV13k4VV0XAHDnXGPGkLiGQiWJ901IUSsVGhBSpEElispQvZVSMiRTKMqQ*)
(*JEUTlYokDSuhSBJJynz3iZtEokHy7e+v+/ye89xz9l57Dedob/F39mJFREQk*)
(*GRGR//9qF4mqVid3QuPDAzV/5fnY9HeRYMfpTgg4nHvSX5KPibaht2TOdIJG*)
(*S+P8ThE+irwfXeqQ0gk/NW7Z1wyoYfvIcFBdWidkjK2yLalXw0yrng/vMjtB*)
(*XO1d2NcUNdSoqTkvuNIJ9zYmalZoq+FEwRm9v6WdEHepskfdQhV38MSbTnXT*)
(*6yRIeHqTCjKR942XjO+CO/u8BzOeKWN8f7yJ/twuEJsXM2OxvRIesLN657+1*)
(*C36JBDJr3o7HHGnzKfVxXdDmk1mrk6SA/5RKK6YWd8FqLdJbfkUOb7owlxO7*)
(*usAvV8vk7W4Z3O1oweVICyD02oe7Q2fG4an5zhUacwRwfPLMSVJVkjh0It/x*)
(*locA1uUHBwntJdChYkbY/uMCMBid5dsgLo5i/REuWbcFkDdkdWjZW1E0993v*)
(*a3VHABb1/6ia1IniToHP0U5qXtuybdo1otjQ5JA3pVAA1x+F8UXLRfESqope*)
(*vSeAZXExVT13RXFJUt6dglIB2CaMGzU9LYphZg2KZRUCkM5Wkql1FcW/wbp1*)
(*pFkA7xOMavsEPPzpm7Yr+YMA1BpXps7t4OGAm/y4xR8FcK1qUsDxFh4KTEYW*)
(*ZbUIwONB+7KZjTx80fvmrnu7AJw8Q1LTK3mYvD4stZYI4HtCj5nUdR7OsOzw*)
(*uN8vgF3DsloGe3k4ZYbrn20DAlh6yb+2MYCHmqo1qSrfBBCdY3D02C4eKnwv*)
(*rtszKADhxsqWz948HLqeuNhoWACNb3WDP67l4RP1hXoXRwQw5YNSs91CHq4e*)
(*yeyLEyewUqL9sbc8D/sCCtaaSxBYGjbbKkSGh1Fc2bMu6tJRu5R0KR6W1HWn*)
(*z5MioDhb5Ml7Hg+1rhjbdksTOPS0cDjoJ4vdLhXnF48nEGhfnWTVyWLwjS+O*)
(*v9UJVHzT2CS8x+KEKSKlORoEVGvnp60vZPFGmqKekyaBpIYLqXW3WeyImDN6*)
(*WYuAWdPW7rJ8Fm3WhV5drU2g3GjK4xcXWZSXnMAWTCMwcUxCsDaRxezNlne2*)
(*zSJgNXK1LWoHi8+7fyRKGBO4aGsoG+TDYp//Hb/L1NcrWlJ2bGPR4siMGZ9m*)
(*E7jX7Fjm6sliQ7rqBW8zAlFxJtvt1rEo3vA93suCgPr2xym5K1j0tcn39bQm*)
(*sKAr9o+6EYuJNduX8mwIwKpqNdeZLBa5TJl2kbqIOxSVPINFnufZjk5bAouL*)
(*7rup6LGYERLttmU5gcLPW0tMJ7P4qtjLZvNKun+nwH+7FFmcZaCl47GWAOsf*)
(*6zr8i0GNaRsiZdwJVElt6nP/yaCkdobwPrXcm5BZT4cZbFfh31FeT0BDv7wk*)
(*dZDBeFZlSdVGAt8uub70+sJg73tZb9OtBDxuzw8P6WCwqcGuqpNa+LUtV66d*)
(*wWe1sUaJXgQUktf6Z7UyeLZc6ofQm8BVh+He6g8MLi8Qi8ryIaDLvj6xqJHB*)
(*K1GjV6X9CUisbBzNr2YwOdxS7j71QimtOduqGDx65NBu7wACloKXsrovGHTd*)
(*+2seBhKYfSj8ZHYFg+Kbhqr37aXxFDiTJ8ig55wvXzqCCIifC19zsJhBLe7j*)
(*rOIIAm2H501uucxgyrdnku7HCCzLOG7/K5dBhbG8thFqmSCNwonUjOrhE3Cc*)
(*wFDv2VnrLjEoWKbZUxFNQPK379s/WQxey9+Q9TaewKUXmnuvpTOoW2K9f38C*)
(*ATXLalVhGoMZFYYOaokE7l97OGBAfaJtdGT9Sbqe4P4FRSkMBozPdBUk0fXm*)
(*yVuSZAbN/muVG0yl+eg3Z1deAoM3QytIchqBmW4m+vLU0+NvlJqlE/hduk9p*)
(*bzyDapeP+B48S6B5n33gkhMM/mnSqmAyCWy89tx2LIbB/4j4uYvUmfpBO/ZQ*)
(*9w307bE+T8DNM7CkJ5rBtnGPtaOzCEyNvN/0MYrBp5YehxUuEtgraSLTEsmg*)
(*xTJbl9vUX/jXQ7ZQ3139j4HLJVqf23aqC48xmOM31pSSQ2BzgGPVWASDUVnn*)
(*TSZdIfBhvsHIknAGRfKPSyO1YVdY7ocwBoPu+3duuUqAC9Pfv5fa9w0k5l4j*)
(*cLOgKzIvlEF70fbPhvm0vk+cX212lMG4iBXLWqjfSqQ0N4YwWCV6LzfuBoEt*)
(*8r/bg6htxOI3f75JwMVmUkDlEQYjjv16lH6LQGth349A6qdiXhrLC+jzdluP*)
(*aVEvELd8d+U2gRurL8YcPcxgcORlE7c7BHIsimVNqUvElU5J3CXg99VfrjeY*)
(*wTkSQjvvQgI9RzsjN1P/K5n6VLeYwBG5sza+hxj0i+JNrqfW5aKuGlPnSfof*)
(*DrtPIMLOKXL0IIP6UjbmHSUExlckXE+n3h5dcDrxAYEwNeXBndS5UpqDUErA*)
(*vjThthW1zrjv+ZkP6f76Y1K+BTG4KcZD2uERzTdWrfQVdea46u2j1JkXH6zJ*)
(*p/4YY1aR95jAqtW/veOp1aWzddc/IeCUsr43kNo9VjZUGmk/9PHhXKlTpYNa*)
(*S6g74664LKRujBVY+D4l8O7oBTMDamUZxzS1MgKvyz/EqlI7xz0Yfk4tktG6*)
(*SpI6UUbP5cAzAufDZ8X/PsDgq7hTBXrlBFr+rJv3lVpW9q/cO+pvlcSVo7Y7*)
(*4bMzsoKAfM4aro06RvbtC9NKAgHKZuQD9fMTC/UItcMaaZdmanG5vIjk5/R+*)
(*1zYa///6kviJnYtfEFj35l5IK3WYXDgMUkvUnLMQUD+J78vIrqL9eV2aVy/1*)
(*Xzn3307VBKqDZ40OU1smlLsyLwl4GfcxonT9B+VnFd6i1il13aNEXZyQobip*)
(*hvYX9yHHqdQ/5CUD5F/ReNuvTJ9LbZa4p+YR9b3kLw6O1HsV2mb41RJIG3D1*)
(*86G+nbg8SvM1AXJR5WcEdb9CEXlJ3bej4HM2tdFJ7cXBdbR/SN1aWka9c/yJ*)
(*LIM3BBYdOSvHUXeP37oupp5A+7U19cb0/Kedqi2e20Dgge6cuvXUWxUtVHqo*)
(*5b7rmkVTdygq1tk2Epj/0Xp2D/XkpMNGP6gf7I2p0qD5t1GpJzb3HV3P1NEK*)
(*Z+pmpSc2Yu8JHEuK+1JOXaz+fHcB9WuNf78zNJ/P6L7O3NBM66FqwtKF1M6z*)
(*24cLPxDwmSB4W0Zd5Sxy2buVQK3/zMMcrY8r7pL1im0E7k6L6DCh9RS5RWHs*)
(*EXWV6JmEY9SLdk92ndhB4PMc3UpDWp8PTi6UeN5FoCY8LiWN1nN62tLZewU0*)
(*vkfc5/+mPnDB0WMyofM/e53+Blr/JgWb7h3gaP7PMHmjT/tD3uuj2/R7CBwO*)
(*73Vvpf0kQx4rY/rofAv4Q+4cp+c58cWg2VcCj+6blJjT/uU2qW5SF7XWYErN*)
(*Y2rlfzr2WwwQyDLXvNVA+12cAzO9d5Ca3+GqFkfr/4RVlP0vGk9Nk9eyJ2m9*)
(*nF5299f/3R69pYja/JxTe85vAsXpUoabTzH4PW+z+d8RAgM/Krc/TKLn+TK0*)
(*+8ZfAoJNEv6JZxjcIP10qYIoB/fSOJesDJrfU/Z8ukVdlyy6b+M5ur8FUyKd*)
(*xDgI6T8ZopXJ4LjAyLJT4hwsjD25/NJ5Bosaly+YIMWBdvPCoopsBuWy62fz*)
(*5TjwfbjztPdVmu/mRGuKKgd7BmL+yNN5ZuB85uEz6k8qvcHj7tPz3GG73kuN*)
(*AwOD4GbxErq+zKtpuXwOFDqfGoiVMvRt009ZX5ODsDWTNFWfMBhYOyxlpMOB*)
(*VkV175nntP94Sw7NmcnB3W+KtUPNNB8GLfkcNY//fqf1RwbDjwZCsiEHKq3b*)
(*jVJa6DxMb47uN+JgBuioW9F5n1ubp3V1Fgdx+9PjbxC6vrlOS/lzODh3pu7g*)
(*1366f5n0s3+sOBCVvrNKXIrFrWmvnlxbRJ+vapiYNo7F09N4nNtiDopcN3Ya*)
(*ybA4vHDnv4VLODAKnFrhIc9i8X8LynfZcvAqSyakeQKLlm2dfa12HAQ6BrnM*)
(*1mXR+rbBInTlIPlKdqg/sMg6STV7utF4Nrj4TbVi8clXLlB8LQdOWQaTWxbR*)
(*/xtmX1jhzkFHRludkw2LxldUmcb1HKy8F+npaM+iVqbYE+FmDlpNdAYu0Pe1*)
(*n9Ft85V3cjAyK90qOYjFa5uT5m47ysHZ2XONs0tYlIySzRIPpffX0W59UMqi*)
(*143j4rnUY+pTp797xOLkkUP1gjAOAoxNTyuWsXgmeeuuLcc4kB/ZWpVRzWJo*)
(*pemFDTEcZJtGuv39yKKbYZOkSzIHKeeScFCEh+K/NJoWXuFA/Fvzq9P2PHwc*)
(*Gj4xuJ7GT7E+tFZSFB/sMmIaRjhwM55fu+i1KCqvKIo9ofeJfs+VrSYohp4K*)
(*mx4edP4EW8ZbGu+qFMchc4e0iIOfQLq24PCrWgkUOKup9Od8AtnBi6cO86RQ*)
(*5fX0+QdefYK1Z5dLzzMdhwtM3aVNhj/BorzHepaB0vgsdvtBJ+1u2L1GQWfB*)
(*exmMs36QFLusG+L0imRnmMvh7X6hvd5/3RCzz0OqpUwe+WMbb7ed64aSXV8S*)
(*NlxQwAND3x9Wl3dDn+jrt+1bxqNJyzZftYFuSEh9WfhuniIaT5+E4Wo9IGk+*)
(*YpgvpYTxW+8Ur7TugaN2ans1vyphe5SP68qAHvB7+FXS4a0y/qewNWtHag/c*)
(*cq+zVro1AbdFW8T0lPXAzsme7U4XVDDDy1UrorcHxIorF4tETsRK/dNrnZWF*)
(*cC7nwDQdH1Vc2XbTNAyEcIqszI3boob8n3Klr7YJwatOVrnOno9OZHt+2HYh*)
(*2BfyH/c78THqzdNMMx8hTJe4e1phDR9/5O0LzfQVQpqLWbnjRj42bG618dsl*)
(*hIHVugb1fnxMqM6vk90jBE+5sbG2BD6Knrf7ZHdECIeGKueqveGjRVxuk0iI*)
(*EDziVxguaOTj7iCRqrvU502Kl3k287Fj1d08jVAhaPv8/pPfycdHkhq7e8OF*)
(*cLng43LrQT4e2P35T2y0ECo+iu0+pKyONz2s+yBGCEte+AqzVdWRszvfNkjd*)
(*qONPB4Y6rtZb9XRdnBC0Rlkr/lR1NP5YctwgQQhNhpqRD0zV0feFclAb9YFF*)
(*MFcwVx0vFPn5JiUKYcxzg5LsAnVUOKljP3JSCA01FpYeNupoeyR4wc1TQlBq*)
(*rI+JWq6OR3Y0/uOZJASjWBWR2w7qWOT2r/bEZCHMrPl69oOzOn6xjlGspv5t*)
(*sWKjmKs6/g+LPCcY*)
(*"]], Line[CompressedData["*)
(*1:eJwV13k0lVsUAHBzhkgSEjKVQpRZ1K6EBoQUSaEMRUlKpFIihMwV5Rnei9Qz*)
(*FXkq6dxbJFKk8KhM93y4lfRoEOnt+9ddv3XX+r7v7LP3Pvuo7T3s7CvAx8cn*)
(*ys/Hx/tVqxZSaM4cgJCY9fP8TxPSNbOeE3hpAGqSY02NIwlJtY2qmH15AD41*)
(*s1UEzxDC9++vjQ5XBmDPW32T3LOE9E19O9GWPQBlu10S2qIJyV030tOZOwBr*)
(*fnJbdRMIUWppyeMUD4D4sa1q1ZcJkedc1pqpHYDMoOEFcuWEBAqKdKUPD4Cb*)
(*xivV9j5C+GPvGWyYOwhJ7+X8UiVYJHks2WiZ+SC4m3vuXWzAIuF26zoP+wyC*)
(*tui2j0fcWKRQwkyzPWkQRreMhP8OZxH9WgmZrJpBWK4cGjyRxSLlLvw3UgcH*)
(*4U7cx+0qd1kkxNGCKZTgwHTz5P6i5yySvtq5QcmUAzLya9q3DrLI14uljhWe*)
(*HNCZvhw29JVFHBq0z4XFccDr8wPdN8JsIjwW45J/hwNZkkLeN2TZxCwgLGBd*)
(*JQeUl2X8+hd9kHPg7AD6uaFM+Oz5bPK6y6FE8y4HHs4dFjmCvs5SELr5Dwdy*)
(*O5uSzOTYZENGSeXtWnxeQ+AaljybnDN5LfO4gQO3m7P23lNkk5lTGm20mwMl*)
(*d7snrFXZ5EdA9qHMHg4ceGDVcBT9xW2OuNVbDsT7+hwpQHOMptbnv+NAQ8Fz*)
(*l2n0s4+vqtz7OKCQxedUocYmmR7nsl5SDjzZ6b14rgabaFv2e94b44DDvJ3B*)
(*1YvZRFPbddr/CwdYi2PO96KVFVqy5P7jQNedzaGiS9hEeqKm7eg4B9zMijg7*)
(*0V//TrXS+8YB+6ZIwSk0WbhW668pDkT3T9uaLGWT7VO5o0kiFLLSDJXTtNlk*)
(*NPj2TrNZFMSklw1XoeOZx08G0SvpSEoX+n7b8NVVYhTeJreFLtJhE5ViA9th*)
(*CQqWD1Rz/kYPuzTkWc2lkORt7/ZQl01OlX1y/LmQAtfQv7ZBj03ma/LVFipR*)
(*qFr0TpdBl2XLaDkpU6hf9V+EsD6b9MeY/rqhQuHNjy/lVmibXVE3t6tR8A1d*)
(*FFmHniM6X+D2EgrnvZ5VlK5gkz+9LSv9V1JorM6/FmLAJo3D31NnGVAQrd3x*)
(*PRE9ergy6Aa6i/vUuBBtEamtPWRIwY8lv6sT/fqqQoGfCQU785u2qwzZROT1*)
(*RLKvBYUtieqlP9EBNqUB+6wpdMSNPfc1ZpPUlv0bBW0oPBOuSziJrnbRXPIX*)
(*OjuNq5OGFtx3rX/AloLNi3iFWnTOmQtuezdTqGzYdE3ahE1e1PjaeG+l8HzG*)
(*bEsVeqWOirrnTgoKCwPDGFM2UVqyO3a2OwWJUBOjn2hRtRzuPbRZpmyrpBmb*)
(*9MkpVsp6UBBWUy40QicLyG1o2kNBd+ei+rPoj/9K+hn7YDyidAZkzNmk67Vd*)
(*0wC69qVAhib6yctEvVRfCqs7NmqYoK/Vi33n+lFImbVzwA29+bZwfP4BfN/I*)
(*r+4cdHH8r5sSh3G/plsfqKzC/Iy2lLqHNg7u8dNDn408GeIXTCEzpfbLarTr*)
(*sclVrCMUXFrlbnigRby+Nh8/RuGH1XhqFnqf6adP/Sfwe/dF+4lbYP4wb1fW*)
(*xOB6rcysOtBX/nsi6n6eQt+FA3r9aOnfJb1T6PIrq2c+oPkVTl+EOAoZot1b*)
(*+C2xnjYpjzRcoBBgmJWnjb5Vujv/TTLm457Vy8PRGvetw8JSKCz9wvhEoXMa*)
(*ljssSEXbnIlKQF/s/TXlkUZB0TjzQA46eG6uKycD80W5/Wsd2iT0vdR4FoWT*)
(*HI7Ab3R5VAPNzKZQE/YqUWQ1myxNLqs1uUrhTuPPSUn0ghuRARHXMP+vL4xV*)
(*Qk93qTTw51LIsRDYY4YOpSJ//IXuurd9LqBHv4wetc7D+E3Mu2WN7hV/pHYh*)
(*n4JFXmOiM5pt6Xla+i/M1/qr0oFoi022LnfQAZpJn4PRVdv1dVyuU+hZI1p1*)
(*HF0Y9LvrSiGFhUXXP0Wh4/PzjBYVUzC3UNe8guYrjZNgoSWOvdPPQZ+4d3hg*)
(*700KxB/UCtABryC16BaFc2e07t5C2wv1fVheSsH58I+CWnRSzJZN79C73r8x*)
(*YqGbhP4pSiqjsPblr+J6tI1wsveHclyvibHxC3TM+cm6qxW436V29q946xH2*)
(*Vdp8m8KDwjqbDvQaEcvO4jsU8pS6371Dn4q9YeRWSaHzatzJfvR9kXnps6qw*)
(*/q/9/ZODNp3FtfO7i/Wmvu+PD+gVollsjRoKIXYbQr+jg+IFVdvRZW/NF/1E*)
(*l4gePn3uHoW9Yy23ptHLxGzM+u9jv8ub9ONfwyb7L9y+lPqAwg2LgiuC6CIx*)
(*5XGopfDN/fdNYbS6+ERp7kMKYxq/j4qhvRI8JRzqKNS1lOhIoHPFm/f/QutM*)
(*6dbPRr9NMGkoeUThekncWin0Qok/NTwIhbCB2j/moN0TJaMkWBQGc7reSqOz*)
(*JE68v49u7en4NRfdkcixCGBTOJX3lG8eWna2Y/aCx1jPQ2WUZ+ekB98a0fV3*)
(*U0tk0amztVzCn2C+iB3aPh/9Iin9tlY95t/A1j6eJSVnpDrR+uus7eXQdhcP*)
(*HIxtoHBtiXUOzwmSb54ZP6WQlu7ZwnPjxbVaFD0ak9XHs4hUSUxmIwWHmfE3*)
(*PG9Ilh+weobx/B1ayvM5qWgYR3Pj1P15JsmjOX82UYjIEhPkeUbK/adTM4WN*)
(*K3WieN9jmVLvyv+cgodzXD/v+yPmrLxbgc6cXqzJc01KjoxXC4Uv+gs38db7*)
(*fY5o8JwX2L8+7nCUQZukHm2pQwcZfjLnxeuYdK920EsKR4XeC/PieSd1c7xy*)
(*KwUrr5VVvPiPSVfT5+g2mw8bJNF6aWpWp9ooXK2Rr+Ht38G5F/N1XlHYU10m*)
(*KY4enuuzK6Ed83+Hh5cIekn6yxrz1xRKJoN2C6F9ZCzkRtDu2rKrBdD9MjJt*)
(*th3Y74xFrv/C/FLNOK33HZ0sHagzhd4zbySxqJNCcUTQpR/o7nlYIv9SSJzx*)
(*mTuOrlnYGHIb/eyp28ox9GWN1tzd3RTC9SWMP6GdDfu+3e2h8Ki7d4jh1Zsz*)
(*3w2/9xQmyiumutDF7qLtMr0UDoZ5r3qDjt0r/bsO3donursNvT5E1VW+n0L1*)
(*NUOHZ+gHaWtnNQ5if3hE+v5BX83eaHiMQ2HH9WSoRIcXOHqqUgqqKw6fK0Mb*)
(*3fb6J5zB/mZxveo6r55az/ovG6HQbmTQnILOmcN6mjBKocWgqN4LHSH/bNzk*)
(*M9bfo8v73dFui9oWDaIbpyY/b0PL6veHWXyhIBOrWWLD6ycO/Es/juP//6V1*)
(*a/Pq/+K6ePtJjH99kOwo9lv3S5uqJtGtOQ18DNrsD6e+wp9Yj3r9be/QEyXe*)
(*ZjNT2A/PH1dvQR98HjVcNkNBQKbo9C30bgn2RmkhBhK2XVL1QjdqHh2qQLfZ*)
(*LhNyRRut0Yx1EmagQ8el1R4tfiT2cboIA1eehKhboKs7Nq+ZL8aAmB2UyaKl*)
(*/mw3VJRiwHpTk/9jPI+IGVXRVGCAvM85Mwet43z54RN0pmz8aUH05UBbD98F*)
(*DIg7Jvh8x/PvYO7N7CJFBv7pGfz0Hq0gFCS7TJkBuV1bR0vQR15+E9NTZ2Dp*)
(*X1U3N6DV/US/muoysKRNUmsfnsfO45aKDHokpkRqGzr67BHIXM6AyYr/etaj*)
(*OVe7L4zpMbDrSLKWOrroZYnKzZUMuD9Mju7F+UDH3GmjoikDij5W27ajjWZf*)
(*vTa9jgG/4Kpjy3He8Ml+QW6tZ8Bg8caFiuhLSwQZNysGPCfUi0XQ39YeXHF3*)
(*AwN1nLZjvTi/1ISuqT9ki/HQPd+dgrbsHRh9b8fA6Nayng84/1jf0VnPcmWg*)
(*vDS5M9WITQScxLr3uTGwW9el9SSafGaOiOzE/eGzrvRDWy7/s2CLOwNaFTGm*)
(*lmiDYgX+Dg8GMqwsVzE4j6nkChOuNwO3hP/VMUH/uNC7WvYgAwJOgT31K/H8*)
(*984w9z/LwMBBSZtCnC9F4yXzRaIY0H0THpCI9i2LEylCF7d1RhxBq06dbOec*)
(*Y+DvCy6eq9GXM30O7T3PAFfynenr5WwS9dS4YHcCA5FKptozOM+6Le8SdcnE*)
(*532c1rXCeVdkUqlrbTEDz/l0gtO12ORRVLT8qXbc3+j4qAQVrLdDevyvpxjQ*)
(*Ufj+N8X7h+yW6sSLWkPQOSB4VE8M5yFpr4cRzkNQaM9SPj6N9xszh+yYiCEI*)
(*s9NJTfnMIhznBXJjhUOQL1F+PLKPReRal64OfzEEcomPrcPaWGSNsbuE0bch*)
(*WHLSP7eXxSJPEvdHOKkNQ0/ojKtYBYskWT/ISNw0DDdyEmfSc1nkzhjXXit0*)
(*GMykLV2bE1hE8feeO71/DEOB3P2m1DC8v32deNhcPww79oZViPmwiNE7/4AF*)
(*X4bBZf1xbQ0HFjFYuogVvWAEzC4tSpYyx/ufT2XNVusR+LbnwcKLaizSF3/A*)
(*dWvwCISVBml2irFIqLRPfmDWCMgrjLfrjxPif8EiYeTxCCizrmyT6SYkx9dV*)
(*JebjCDhedHNUx3R4uuzSTmdZLjg8ulxmcYuQrb3lxueAC8L7TvZ1phCi+EOq*)
(*9oU/F2aSCj++PE6IE91fem4/F8TFF9h7ouNfsXNNDnBhR/aKotFQQr6XHI/K*)
(*DeDC0Niu9ZLo197vbYIOcSH+ZKf65qOEpDSXtkke5cLdqWWx7MOECOXZDdlF*)
(*cuHpgWODpfsJsUgq6uI7w4XwJZEeluiQE3xNVeiGicAXTf6E9G+rKlGK4kLE*)
(*k6mcIT9C6kSVQj5Gc8HRaClV9SUkPOTDdOIFLmzY5KiR7k1Iuaf1KCRw4brC*)
(*GR1VNGOX1zuOtvxxT7fMi5DtWtvYu5K4UMk1VWzyJMTg7f04nRT8P7ukgH8P*)
(*IQHPZE/0oo+P6oek7CakoDooICMV3+/yyEIZLZ2mbj+VxgURJ/X7Zh6E2Eae*)
(*WlOezgWBkcmghl2ERAZ26O/L4EJpKlVyQVe7rVCTz8Tnbxp53O9OyCfrBJlm*)
(*tJ7MfJ/D6P8Bta2bPQ==*)
(*"]], Line[CompressedData["*)
(*1:eJwV1Xs4VNv7APAZt8glIZkJJX4kReSa8q6VkkQhHR0lyaVSqVQnJEVyvxUK*)
(*FboQDnItpKIkJXRRSR0yZm9MkSIpzZ7f+v41z2f2s/bz3ta7tXYddPUTY7FY*)
(*0mwW63+/Wrcl1NrSeeA55t17ekANdzOr+fsyeBCZ8nFq8IMaTl0XUS53gQdG*)
(*peaMc5caZr0X2m+8yIONNyZbFz1Ww5+mJ0NeZvEgSKzY42uBGs7Bwx/e5fBA*)
(*ye7Txu4ANaze3p7LL+SBmH9PiNrEXDyXf0GPaeBBDYS0rJebi/eJS3WfH+LB*)
(*rkGZz4FGczA7us5kzewByD8jVDl2ThknjyWb6lsNQPayf50d1ZRwsCN+d9B3*)
(*AKouXzmXlqOI82UtdV4nDoDkgqwTVTUK2KhBVimzdgB2xFx5bWomh2+5sW+m*)
(*DgxAsfIio7w/MjjI2ZrOl+WDm7bKWIKmND6/yrVF3YIPFZZvQ09tksI/kkqd*)
(*y7344G9lkXftpQTe2LI48ngMH9KVYhwU4sSx5FiUW14lH4ozLxbN/0sMWwYc*)
(*D8BVfHjG8GIkXcXwfv7e0zxia5XEeaNOYrire2OJTg0fLjr84/1krRi+0aQm*)
(*UXSHD7SKhme2mRhek1ZSVdHAh9dcxwdNc8RwpHmX0qMWPkQ9yElQ7mZjJkz7*)
(*JdXDh4UpHgvLfNl4KiDrQPoHPpwJ5+dO7GTjb1tnzbT9yAd+f7WRjScb802n*)
(*V+f9x4dCtnVUzxY2fvrlVbXHJ/I8Zde4xTo2Tt8emdlJ8aHyrk342cVsvHhl*)
(*v1fdGPEfhcHd4yyss9j9z+5vfGgPOnV/1hgLa6i1Z6p+J/FHPc+s/8LCihO1*)
(*L4+M88GvVt6NQ7Pwj39TbQ0n+XC3reLd724WbpyH9K5Pk3rWJ910esDCW6Zz*)
(*RhOlKCg6P2OmUTILjx6q+NtyBgUORjuWrUlg4Vj6UfMAsUi11XB7LAvXvxzK*)
(*XiFDgaCZXZkeycKahSbrhmQp+PnE/rHecRYecmvJtZ1NQUaGbN2bnSwcVjbi*)
(*/HseBVusMm84mbPwHB1WQ746BXfGzD83LGfhsiwlPRcNCpx6XacNjVm4P8pC*)
(*eFOTgnKO8T/zlrCw3baIoi1aFPQ+aHo6ZyELz5KeI1ahS0EtyzgyRYGFr3mv*)
(*rNptTMFfL+4rLnotQq1DP1NnmFCQqXG9WLxThEYPVgXeJB4VeEnwn4mQdfji*)
(*xYPLKYiO3D1R+VCEurLVrvqbU6CaqFIZVylCUl0TyX7WFHCb8xhOmggF2JUG*)
(*+KylwPcv86pGdxFKbd9jL25HweU/S3tM3ETotpuO7nVihVjfoiJnERL3udTP*)
(*W0dB9Ya8VfnrRejyqbituxwoWDZWvKjLWoQ6av3svDdR0Bxt4auoJULGBpoL*)
(*vf6mIPXzpINwlEHqup7Rch4UoJJ1jx9+ZpC01mVBHbHhV4+cpCEGfVLlVqls*)
(*p6AgeNbe5TwGJYuprnm2g4Iy8QC7B28Y9OW9vL+ZLwVHnQ02vbvHoO4ux2c8*)
(*4t5ut7Xf6xnU3JlgmOpHQY67XYJSLYMuPZb5KfCnQNGsRcynkkEOFZKxeXsp*)
(*MPeUi7a9yaDCWGGR7EGS3ysnObHzDEo/s1KhjvjLwXfJh1MYdDr8RJD/IQqG*)
(*Qsxd6UQGuR/9taLpMAU9nXcu9sUwSGrnj7Z/jlIgcbRIfHY4g3wsRkb6QyhY*)
(*U7A5OXAfgzTpj8a1URQ4e/0Ykndg0MXvzdIeZykIOnDKYo09gxRFJX3TxL65*)
(*daJwOwax1U4mQQzp74jVb7Ytg/jrNYZb4iiYucQ2ctVKBhWXeua9SSb1n95s*)
(*Fm/EIO36tcePp1BgUrS2eYYhgy63LN3ISSXxTb5pjFvCoKQ+4fT2cxS8OPxY*)
(*lK3PoEOzc9z5aRR09L849V2bQebHehXGMymgZXr7jnIYdCuihUrPomCl3rJR*)
(*SzUGLUouazDPpuD8LuUd7LkM4twMDwi9RN5nEu2Vq8KgP92aLewcCoItVLtm*)
(*KTLoGCV15Trx0Ycf308qMGj02+iRtbmknoKl1jx5BvXNfKAVl0fBb+Xj8i2y*)
(*DHq40uuk4nUKFthd/NA0g0HW69e5VRKPWjcUtkkxqHqLkYHbDQqmOva3vZdk*)
(*UH6gqPtiPgXS7YEK4hIMis3LNZ1fSMFpfeZYHItBrNIY2SZiw/jwnhqREIXU*)
(*HeTtKqLAXzoxmWaEKOAVpBYUU1Do6chzEwqRk8Snz0tLKdAZ2aft91uIEqM2*)
(*rP+PeIfxa5f8X0L0TOJOQWIZBW/hbaxgSojsJJO9P9+i4I/1f3JRP4Uo6uyv*)
(*+9nlJD/9affuSSF6KOmn7lBBQfEu6qYxsY3UyneFlRSom7m6jk8IUVj0TdOt*)
(*VSS+zpHibcT1UsrnZ1RTcL86VuLpuBBZzBA4+teQeRr4drvyuxAtk858qF1L*)
(*5sl1TNg0JkSBseILXhMPtX+1JX+hEumDJyPrKOhWdT8z+FWI9GXsLPvrKQic*)
(*nSJYQLwnriIj9S4F8bahio9HhahARmMcGihgrRFbEki8cOZEac49Ut/yeahz*)
(*RIh2xnvJbrxP8tNoNY8hzpnZtkdInO5hN38N8cd485aSByRf+saUJPE82Wva*)
(*2xvJ/NqONT3/IkQeCfIRsk0UbB0zC80kzpQN6a0nVgk8u2Av8dsEvnXAQ3J+*)
(*paDKhlhFzjmL84iC1Z5Hl3OIXRPvTrYSn960LGfqsxClyum5BTf/b16Wjn8k*)
(*7kg8X6H3mPTf4LhxC7G8PKPwjphJ19xaTeyYtHd/dAvp9ysj/5vE8fJvnpo9*)
(*oSDbp84jl7g1CelRxFP2z0wvE0splESlt5J4xA6NXyFekzyXZ/uUgo/n6jJu*)
(*EEcqnIFxYofJKm45cWPy6OVrz8j7yg9GNBIzCh6/XdooMG361fqGeGXKY3f2*)
(*c3J/F3mPfSUOnWVcU05ss7tmUoHkV5tyWWlnO9mHQrEPJsQ/Z0kfmtVBgdJ+*)
(*j8vbiM1Tj7TfJzZd/swqjvioYt/iwE6yzzd7V94lrkx1iNV4QerttFRynHhM*)
(*8Tb1nDhUy8bYiPTD8JyWbdhLcp+cr5sdIt4/OynP4BXpt8e+2beJh2b7bot/*)
(*Teod4bXBmfRf93xnrVUXBS25xTdvEPsqWasOE4ddSn8nJO5XUnq57i3Zj6XR*)
(*ZffJPC1IO2n4k5i75t/NumT+digPJxS8I/muuNV6nrhHudFO8j2J1z5eM/Qb*)
(*yXdea1AFcbrPq5rvxBe0X+R49pB9NjH05SCZb9flnyZrPpB9/fOXeTCZ/2eu*)
(*rJv+veT7l/VEq/GHEBV6SL9W6qOgcqwyx5Pcp+hdiqL7xB1NbtUi4tVBC9zn*)
(*9lPg+GZZgQu5n3fPoRmtA2TeXU8kLJkWouws++VH+RR8SnSqGSUOvurstYAi*)
(*99Ou6VDNHyEyrdh5J5gm96meneVM9kPJi9O79YcpaKjTvXCPTfbprKYn8aMk*)
(*HkPDk4dlGBQ69+m4+VcKHlbKuYfNZNDW+S/nDxCn4n3VCWSfqRj1H7f+Rs5H*)
(*6kzeIfsucSN70ZdxCi4U8sLslBgUloRjnX5RsNgs4tUKdQZ5ZKyv/kVc3vwm*)
(*NEmDQZZXXD7l/6ZgbF9WJl+TQRMl3pbMNOmPxMiyPC0G7X8eMVTGULAk2KrB*)
(*UY9BnrIP7RUlaNi52DQkdDmDWnWODJYTj+neOzRlyiBTG51oF0kaWqTiVoWa*)
(*M2jm4ehH56Vo2HNExS3OikG33zrYzJGhQSljgfcbYJDCtdfLuQo0NOgd3q7j*)
(*xKBGS0pTR42GCfUKKjOAQQauF+41E4fFtOum7mfQhX3rtvtxaBAEZugmBJL4*)
(*coqyCrg0qFq6eCUGMUhNIlBFX4MGh7YXV++GMuhw56SM4UIa7t+pa3+ewKCF*)
(*/tI/LJbQkNOr01NdziDX8ZVcmnhqhwXXvYpBZ04fhvSlNPCsOguENeR7mN0T*)
(*N2ZIw44o4VX3uwwq6CzRLDKmYXHSyRnQQuKzcrHnWtCgfiKztecjyV8u+9If*)
(*TMMF13XjIC9CvlkdjcWraQgSfZcLUBShDF1xeqstDXJl//2VqSxCk2j/spo1*)
(*NJRljB1nc0Wo9pjN4wPraGit+OetpJ4IrezjjfY60lBcV4jeYhFaW2mwusmd*)
(*1P/ku+KUUBESc5Hp8dlKg6lh7DHRSRFq/Eoflvqb1KvmUkdQBDm/9NrVDR40*)
(*1LZx9X1jRcikUI39djsNsaZl+w5fECHNHMlGgTcNipR2nFmVCE3F9a1S2U+D*)
(*ZfUKS6+vIlTsnWa1+zQNFhqPsqStWFg6Vj5PKoKGE1zLSh1rFvYri5EqID5W*)
(*9G/A6lUsvGD6xGt+JA1pNqg+ErPwhXTfA7vO0uCoLN6m6sDCEU/MrnrG08DP*)
(*MAhI3MbCW5d2S7ulk/4tP+rx7ykWlvql3o0KabCX9ZnKf87CDyLOzA17TcPz*)
(*oJ27a2PZ+O4BQ3bXNA23NLJ0lV3EsMqG2wlJeoPwQUazu8NWHPso7rwX6joI*)
(*mut9f8c4SOAflhuzokIHYdrMol/TTRLzXTmqY/mD0DOvINkiTgqrvli0Krhj*)
(*ED522lVub5iBbcw8ZE0nB8G3RyTx5pc0bk7YE+qiNQTNjXEqZ3xm4sS1d9MS*)
(*1g/ByOxDc5WaZXHlmMBJ79gQ3OVVP811kcdc0Y7KvitD8D4nbPuGVwo4+MfE*)
(*vbbHQ1Bq8sc+zUARm/63O4DzbQiw+NBkqsRsbLJoftMZzjAEPNH29+majZN9*)
(*q2o3rR2GZW2e90bqlfCn2L3umw4Nw9X9F9+vuKaMjyn65u3LHAZGQXV0VrgK*)
(*3h1nHT/8aBhmWsQJThyagy/7uWtGfRkGY8PppPV/qeIn+hl/u6oIQCPFEMWv*)
(*mIs39d0yiwQBhCbnHTA2U8PcKYWGjt0CiNnfvOKaFge7UHtKI/cIIH1iw9In*)
(*/8fBsa8e5pjvFYBIv3bDF30O/lnyT0ROgAB6/wzKWphwcJd3r13gAQFo8jZe*)
(*7FjNwSltpS/ljwjgu27kE0lfDpbIdRx0DBdA0DbBVFoBB1snFnSzTgkgMrrJ*)
(*5n4xBweFsJ5VE3v0vi0dKuPg/s3VJeoRAgh2C5hhc4eD70urB305I4CaEEG+*)
(*4AkHBwd9/pMQJ4AkX/3wDcMcfMtr7SjEC+B6j8HG4BEOph1z+8aJza9o2eV/*)
(*4+AtepsfbksUwCz7tFLRLw42+VgfY5AigHhlt623Z3JxwFOVkD7ihPZbfnwF*)
(*Lr56OzAgLVUAE8u3ZSspc7HiuYVO0+cEIKQcQw7O4+J14WE2t84LIPFbgHbO*)
(*fC4O3/fWyCdNAMfioieea3Px7a3LtOamC6A8KeHLtB4Xj6yNV2ojdrLxkzVY*)
(*wsX/D1KnUtk=*)
(*"]], Line[CompressedData["*)
(*1:eJwV1nlYTtsXB/BSGsQ5501SVJpo8FMkqltZllK3AZVIkUSTiEJK6CrRPFCi*)
(*OUMTFYWEEJFM0UAJje851XuTiAaR375/vc/ned5znr3XWt+9j8r2vQ6eU4SE*)
(*hCSEhYT++1WpEJV7kdINcfMk3HRmamHr5Cr+rjPdsMqw2TZdSguTLMOuTU/t*)
(*BoWvPHUJUS0Uev/777Vnu2HbsF1C/3dN7JwYOdSQRv6f0bum5p0mZmP/h5bs*)
(*bsiyu+7cmK6JCq9e5fALyfsj6i+5qmvibH6qxmRVNzxtQBEVUw3cJSLWerqv*)
(*G75HDRj6u89H4ZO39cx5PeB5zuf4wcdqmDCUoK9l1AOXbRxG9G1VMdgWW/Z6*)
(*9MCubVL33JuUMU/KUL0prgduxqsIvVOeh7pVUtLnKnsg4KrM9nfnFfCqo3BB*)
(*Uk8PnArUtU/2nYP77Iy5PCk+jIawymnxcnja1KFWwYAPDtIOazMfyOKP+BK7*)
(*a258sA+qXZe9ahaurdUOD4rkA35I6av7OROnDkU45pbzId7PeSi2ThoNfYN8*)
(*8TofZl5xWHTgsTTu5u881k08NMIouVVLY3Pr2mL1m3yY2+Iqb1opjZceyokW*)
(*3eKDiGXZbvlCaTRPLr5eVsUHg+TZeuujpDF8ebN0TS0fpL2NU+uspXHyiFoD*)
(*28aHB0m7y/JaeDjmm+aX8oEPijGLHQebePh1Ez3N7CMfagL2iv/1hod8/YlV*)
(*uZ/4ENoXkNVWx8NnA403XDr58GZCLmTlHR6mbAk/95rlw5e5rjHZWTzUNuly*)
(*uz3Eh5IN40W5XjxU13b65f2VDzlNnX7WO3ioKPfqnOw3PjSq8/VG3XjIfK9s*)
(*2D/Mh1RFh/vOzjz8cSXJTGeED3ZfN75aZcvD6rkrNS5O8MHLe8u2S3o83DCR*)
(*PRgnxoKBjcLv88I8HPQvczYUZ+HTlbA3lZMMRnE1j3uIbxevD2mcYPBOQ1/6*)
(*X5IsyA7sWkeNMKhUqGfZJ8WCUdyNbwUCBvsca3PMeCycn/b81vZmBo+Ufrb7*)
(*OZcFesx9xnARg7PUharyFFho/dLxckcBg6Vp0hr2iiz4Da1wbLnEYFeEwe8C*)
(*JRZmWdVX1uYwaLE5rGiDCgt/RA+9rD3DIC0xa0rZAhZ27DattAln8IK7yXXv*)
(*JSzkdZXs93RlsK5vNElcj4VO3XR/x80MDu69vqeA2PXazJernRk0DtXW7l3K*)
(*wrinfpbuBgab0+XOey1noehmZ9a8NQyKNX9P8DRmwWQ0uNbflEFfixLfHatZ*)
(*sFtVpPJ2HoNJr3z+FrFgQWr+YyNaicEKR/UFF4lvCwou2SgwKLIjo6vbkgWl*)
(*3/YBL+QYzPwnetN2axZ+2Pd+4HgM1ld6WrivY2Hhxw8X40QZXLJQSdXNmYXR*)
(*we421RYaFRa4npzuwsJME28dQRONEiqZgtvERd1pnyre0NgpO+e6zBYWygxt*)
(*bbY9pzFhiqz5860szNCtshq+R+PA+xleyzxYMMNoYfl8GlubbZ93E2eYNOcs*)
(*u0jj49exOkme5H01H2KccmnMeCI5KvBioSnA0+xKOo3WZVOjcneyEFZprn46*)
(*kcbCqN9FUntZOCXu1LwlhMaU4ybUbeKsixH1r4JoPBZ6eJ+XPws5ECFmHkij*)
(*04Hxvx4GsPBBH/+30p9GsW0/Xhw8wILwlGz9IC8adxh8/tx1iNRLYZ9Px3oa*)
(*lbiPSyojyPq/FrSd0qPx7LfHEi4nWHghM6bzbDGNzJ/ijgni28M+P0V1aRSW*)
(*OxoPkSy0dBUMRy+kkW+l2F8bTdZXEebyTJ3GyyWuuW8TyPxM6bNTlKNR7c7q*)
(*oKBEFq78eFeVIUtjZu2itfJJLIhsa0tWmkVjfMfviS2nWLCUkz+2RJpGf162*)
(*Ez+ZhXk8P5O46TQuD2ynhs+xYFolnykzhcarYbVsShoL4rU8t/dCNGomlFYt*)
(*T2ehy0w+7MIfCuULQn1DMlgIyrDvwN8U/mpVqhXOZgEN/L7cGKMwkBXLukgs*)
(*7tZ6JnOUwsGvg/tX57AwP8T+TNQIhR3THqhE57Lg9Nw/0+87hY9M3I4yF1lQ*)
(*OeVdsWuIQmMrS8dy4rzGNczBLxTe2KC70PES6fdT83sRgxTm7fnTejaPhadW*)
(*XjOuDlAYlZujP6+QBUn9qACDfgqFSiKlHhIfXjtlnUcfhYdu7+3eXkTmMfPU*)
(*oTO9FPo2QlL+ZRb22n8rF+UoXCPa+e+iEhZ0PRvPy/ZQGBdhY/WJ+Gh3l6lT*)
(*N4XPRW/lx5WyYBN8pSOzi0KLqQnu/15l4WtJ7mKDTgojTozfT79G+rGW+xTb*)
(*QfYz1VPBuowFK8s58Ww7hSvETFoKy8l8Tg37XPCJwiMnC/Q3XSf5sqnPZIjv*)
(*iM08LX6D7M93hXXoRwoNxAW2XjdZeDtyL8PnA4WLJc49Uqtk4SpVOhn8nsI9*)
(*USLKTcQBPrERksTFEnuPht9m4aHrmFBOK4VakhaGXXfI+ZFZ8b61hUKf6LIz*)
(*SXdZAE5V/yhxvqTiMFSRPEzfGLaAWHXa95Lse6ReSyyHIt9RuC3GTWrtfRaW*)
(*LlZhVhJnT3vh85u4x3Zc6fdbCj/GLK8tfkDyHNk+9wHxXKkLaluqWXig0j71*)
(*JLFL7IwwqYcsJLqIfbQnPid1qP0OcUO5V5Yq8btYvrHvIzJPvtOtxpoplJlu*)
(*lyZfw8JcEbH2RmKHuLsjdcS9d903lxMnTddwDH7MQslbnepU4vq402UaT0h9*)
(*3hyWOkY8Y8Yk1UL8wm+jyR5i2/idu0/WkvNo4JW9O3HMjLfPlj1l4Qn11dqZ*)
(*uC5+pQZLfCW5fsFGYjGqOCKljuTh1wG+E7F5wuxus2ck/xLD4VuJw6njMEyc*)
(*aOQs7EtcnTCYeeE5mZ91N7aGEE9SLj/tX7BQEyOTnkhskvjESfglCxNXosqL*)
(*iEPoJTevERdcVy6oI65MzJTe9orcJ9sFBweIR2kJf7qe5Gfsh/IsUp/lSftf*)
(*3Sc2q3C4tIr4ANOhvec1qe9HWiiQuDzJOkrxDQvOu02WFhMPMRXsS+JDnn0m*)
(*fcQ6p1TMjjSw8LpOVUGL9G83Lz53YSNx6sTrPcR9PI/NMU0srF/2tEyC9H/B*)
(*6deVRs2knxbvP20h9pA2lu0nvn6iru0mcZe0dIPlO5K3l6FmB8l8KScf1Rkl*)
(*Xp/qUfKJeOvM/tj8FhZ2rvPhW5F5bJtZbTH1PemHtHjF4jay37l1+8qIo2+5*)
(*SRQRp6q9yXZtI/Xq6R6dT+bbYWnnyM0PLLxvbr+8iMz/cwehAq92FhYNdFse*)
(*IPkpdJFoku4g51N2rS+P5OvkdubPfWJxxWq168Sr9ik7ze4i9RPZ7ShK8nn3*)
(*1Erxuh4WvGt7zn4ieU5P+3vpAT45r8oqHHL4FAaft3NTZsn9r5OQ6clSqF+2*)
(*7VYw9996Hr7/Q86D4jfHvLX6SZ5fxHT5CijMpB8+jRkkz/9j5D7nG+nn7GfD*)
(*y7+QfPtFXlAfpnDTvIZ5PcRLQ6o9lpLzTEa3K8j4Kwux+vt9tpLzLm6tsObA*)
(*MLnPzEwdBT9J/uMxas04mceGV2OtojS6nLG6MU78wDm0Q1uMRsMs+868nyxM*)
(*pXlGYeI0fi92N5ycIPk8sRWNp9G4+2VYX+kkC/G/ZBL4NI2uUo/+ZkQ5CNPR*)
(*c5RSoLFOfX/vNWK61SYgSpFG/RXqJ+2nchAoHOQuOY/GaQEna06LcTB79qJK*)
(*WVUaK95Zr5glycF51nqhmyaN1IWmpXMoDgzeSMbkL6Ox2pBVUpfjABsl/ppG*)
(*7rOFDqn3HhMn+uBmoQ00pu6y3OIpz8GGjEnDnxvJ+rKL0vLncDDubKAx7kKj*)
(*nOgeGS1FDm5tnHJXbQeNAa9HJHVUOfiXm6u28ACNql4SPwz+x8GuxG/M5Dka*)
(*HYZN5nDENfvVX2dn0Hj8WACkLOJgr932FrNsch+mt0UP6ZD9GR56lE7u+/zX*)
(*xUpFSzg4mmcpOFxK1mdk//ccAw72e268M+0J2f/09IxfyIHZg0xdxx80eqTV*)
(*V19exUGezfZDR8ZoPLNAhNtkxoHwrz9DhRM0jqzcvfimOQdaGspLxYUZrAxc*)
(*8cTPkgPzN5qFJ8QZNOnoHmy35UCqyl2Xk2FwdfnCVQ+dOGDfXb6kt4TBKfaS*)
(*bTs2cfBr+VB8vx6D1V+4ADFnDpyD3E0v6JPnF104b+NC1vPB9bOcIYN6hXLC*)
(*77ZwsKazPXIukO/N7KnVAncO/Hs0NgWS77Wx6A5Tmd0cXOSlDwXvYvCye7KR*)
(*9zEOmuz9AoqLGZSImpErFsaBuOXA+qelDHqWRorl/+fI4Lc91xhUnjjcxA/n*)
(*4Iyk3w2Vmwympnj4bT/BwY6oktZr9xgMe7rsvGsMB2ninwMUXjO4aVGrhGMK*)
(*B21H/1xcMEy+F8cVWlcWctArpDP1B/DwQdjx2UeaOHi/qVYvY4KHd/10hJsn*)
(*ODh7kNoUXiONMjYVsfEavXC7QCe97OZM3MFsuxfi0As57vvNGu/K4A/DtWkR*)
(*Ib0QlHMqsv7xLOQ7yMsO5fXC6oNHM/TGZVH2jaZpcH0viHyvyry4UA5XLHOR*)
(*0h/pBTaxWdLdRx4fx/qE2Kv0geG/R22NGuZg3Oq7ybFWfSCmVC40ulgBy4cE*)
(*azQC+0BE3DDr7D1FnPNna3lHVh8U2Y7f3GI6D4N/fL/34kkfHDmuMpi/TRn1*)
(*P3n7yn/tA4q/c4uKkQrqac57eFy+H+ycjA8GSqhigsf1ynWr+8HwWMmXfYOq*)
(*2Bm102mdfz+8nrw0vOStGgYyHrm7zvXD/BFZi3+uqaN3tHFMf00/8J/pVDte*)
(*mI+Znk5KEQP9UFhgMXQ6cgE+1Trj7CAjAJ/0VG/zXRq4ruPqsnAQgO1+nv8a*)
(*T02cM0ZV1XsLoFuSMdW010J71qck3EcAQv3X4qw3aGFU46Ps5TsFQFlMk/Bz*)
(*1sLR4oNh2b4CGO1PCit318Jm93aLPX4CcKtLPQr7tDDxRUnDjP0C8J/bdtI9*)
(*WQtFc2x7bUMFUBo9ZvXkrRYax+W3Cv0jALn7ob0D77Vw3yGh5zeIBX/kSmXa*)
(*tbBr/Y1ihTABREwsq/DgtPC+hMK+gePk/d0vr4qNamHwvn9/xUYLIKtt3XIH*)
(*OW286rZ6EGIE8KzbdfMRBW3kbHM6holpiWWF+crauEFj/aPNcQJ4UDRQOaGp*)
(*jXof70QuTBSAV7T5jQIjbfR9JnOog7jGauusJlNtPF+xxzc5SQDST7OyJlEb*)
(*mVOqayZOCeBAn7HaRmtttAw9suLqaQGETd+nHL5WG0N3vdPdkSwAv0VHzEsd*)
(*tLFi02KV2SkCWH7YIrFtozZ+Xh0j/YK4KbBKSHyzNv4fhDW4bQ==*)
(*"]]}}, {}, {}}, AspectRatio -> 1, Axes -> {False, False}, AxesLabel -> {None, None}, AxesOrigin -> {0.5806632489308791, 0}, DisplayFunction -> Identity, Frame -> {{True, True}, {True, True}}, FrameLabel -> {{"Energy [Hz]", None}, {"Z [mm]", None}}, FrameStyle -> Directive[RGBColor[0, 0, 1], 18, FontFamily -> "Century Gothic"], FrameTicks -> {{Automatic, Automatic}, {Automatic, Automatic}}, GridLines -> {None, None}, GridLinesStyle -> Directive[GrayLevel[0.5, 0.4]], ImagePadding -> All, ImageSize -> {501.51171875, Automatic}, Method -> {"DefaultBoundaryStyle" -> Automatic, "DefaultMeshStyle" -> AbsolutePointSize[6], "ScalingFunctions" -> None, "CoordinatesToolOptions" -> {"DisplayFunction" -> ({(Part[{{Identity, Identity}, {Identity, Identity}}, 1, 2][#]& )[Part[#, 1]], (Part[{{Identity, Identity}, {Identity, Identity}}, 2, 2][#]& )[Part[#, 2]]}& ), "CopiedValueFunction" -> ({(Part[{{Identity, Identity}, {Identity, Identity}}, 1, 2][#]& )[Part[#, 1]], (Part[{{Identity, Identity}, {Identity, Identity}}, 2, 2][#]& )[Part[#, 2]]}& )}}, PlotRange -> {All, All}, PlotRangeClipping -> True, PlotRangePadding -> {{Scaled[0.02], Scaled[0.02]}, {Scaled[0.05], Scaled[0.05]}}, Ticks -> {Automatic, Automatic}]*)
