(* ::Package:: *)

(* Mathematica package *)
(* 
******************************************************************************
This package takes code from the model developed by Maren Mossman and Peter Engels
and uses it to calculate the magnetic field generated by the bias coils.

Most of their code is protected in the private namespace to prevent inevitable naming
conflicts.

KNOWN ISSUES:
Sign on the X and Z bias currents have to be manually flipped.

Their code for the entire trap is used, chip included, when only the bias coil portion
is needed. Can be streamlined.
******************************************************************************
*)
BeginPackage["SMThreeBiasCoilsModel`"]

biasMagVecField::usage = "biasMagVecField[x_, y_, z_, coilCurrents_]";

biasMagVecFieldLEGACY::usage = "biasMagVecFieldLEGACY[x_, y_, z_, bx0_, by0_, bz0_]";

Begin["`Private`"](* Begin private context *)
(*
******previously public portion of the ME code*********
*)
(* Begin constants *)
\[Mu]0=4*\[Pi]*10^-7;
Gauss = 10^-4;
mm =mA=ms= 10^-3;
in = 25.4mm;
A = 1;
\[Mu]m=10^-6;
nK = 1*10^-9;
MHz = 1*10^6;
m2kg=1.6726231*10^-27; (*Mass conversion from u to kg*)
gravity = 9.81;
hbar = 6.626076/2/\[Pi]*10^-34;
hPlanck = hbar*2*\[Pi];
cLight = 299792458;
(*uproton = 1.66054*10^-27;*)
abohr = 5.2918*10^-11;
kB = 1.380658*10^-23; (* Boltzmann constant *)
muBohr = 9.2740154*10^-24;(* Bohr magneton *)
gj =1/2; 
mj = 2; (* 2 for the F=2 state, 1 for the F=1 state *)
gjmj = gj*mj;
mRb87 = 86.372836*m2kg;
mK39=38.96370668*m2kg;
Inuc = 3/2; (* Nuclear Spin for all three options *)
gs = 2.0023193043622; (* Subscript[g, s] factor constant *)
wiredia = 0.0253 in; (*0.0253 fr 22AWG wire,1.024 mm for 18 AWG which is 0.0403 inches , 1.45mm for 15 AWG*)

\[Epsilon] = 0*mm; 
(* Based on CQ's inner dimensions sent in Jason's 0421 2020 email *)
YbiasCoils[I_] := {wiredia,I,1.55in,2.33in,2.362in,11,11,(0.4525in-\[Epsilon])}; (* z\[Rule]x, x\[Rule]-z, y\[Rule]y *)
ZbiasCoils[I_] := {wiredia,I,2.15in,1.74in,3.228in,11,11,((3.228/2-1.319)in-\[Epsilon])};(* z\[Rule]y, x\[Rule]x, y\[Rule]-z *)
TransferCoils[I_]:= {wiredia,I,1.57in,1.84in,1.181in,13, 13,-\[Epsilon]};
MOTCoils[I_]:= {wiredia,I,1.57in,1.84in,2.0982in,13, 13,(0.591in-\[Epsilon])};
FFCoils[I_] := {wiredia,I,1.490in,1.770in,1.19105in, 1,2,-\[Epsilon]};

(* SM3 Atom Chip *)
(* 
Can only use 1 set of wires/coils per driver;
Driver 1: Za, Lb, Tb;
Driver 2: Zb, La, FF;
Driver 3: H-wires;
*)
C2Cwirespace = 0.150mm;
Hoffset = -425\[Mu]m;
WireWidth = 50\[Mu]m;
(*Driver 1 Options*)
Za = {{+5.55 mm,+6.55mm,+1.0mm},{+1.0mm,+5.55mm,-6.0mm},{-6.0mm,+1.0mm, -6.55mm}};
Lb = {{+C2Cwirespace/2,-6.55mm, -(1.0mm+C2Cwirespace) },{-(1.0mm+C2Cwirespace),+C2Cwirespace/2, +6.0mm},{+6.0mm,-(1.0mm+C2Cwirespace), -6.55mm}};
Tb = {{+6.0 mm, +6.55,-1.0mm},{-1.0 mm,+6.0mm, -C2Cwirespace/2},{-C2Cwirespace/2,-1.0mm, -6.55mm}};
(*Driver 2 Options*)
Zb = {{-5.55 mm,-6.55mm, -1.0 mm},{-1.0 mm,-5.55mm, +6.0 mm},{+6.0 mm,-1.0mm, +6.55 mm}};
(*Ta = {{-6.0 mm,-6.55mm,+1.0mm},{+1.0 mm,-6.0 mm, +C2Cwirespace/2},{+C2Cwirespace/2,+1.0mm, +6.55mm}};*)
La = {{-C2Cwirespace/2,+6.55mm, +(1.0mm+C2Cwirespace)},{+(1.0mm+C2Cwirespace), -C2Cwirespace/2, -6.0mm},{-6.0mm,+(1.0mm+C2Cwirespace),+6.55mm}};
(*Driver 3 Options*)
Ha = {{+1.5 mm, 5.0 mm, -5.0 mm}};
Hb = {{-1.5 mm, 5.0 mm, -5.0 mm}};
(*
**********End formely public portion*********
*)
Bz[x_,y_,z_,coil_]:= Module[{a,b,c,d,r, curr,dx,dy,dz},
dx = x - coil[[3]];
dy = y-coil[[4]];
dz = z - coil[[5]];
a = coil[[1]]/2;
b = coil[[2]]/2;
c = {a+dx, a-dx, dx-a, -dx-a};
d = {dy+b, dy+b,dy-b, dy-b};
curr  = coil[[6]];
r={Sqrt[(a+dx)^2+(dy+b)^2+dz^2],Sqrt[(a-dx)^2+(dy+b)^2+dz^2],Sqrt[(a-dx)^2+(dy-b)^2+dz^2],
Sqrt[(a+dx)^2+(dy-b)^2+dz^2]} ;
\[Mu]0*curr/4/\[Pi]*Sum[((-1)^\[Alpha]*d[[\[Alpha]]])/(r[[\[Alpha]]]*(r[[\[Alpha]]]+(-1)^(\[Alpha]-1)*c[[\[Alpha]]]))-c[[\[Alpha]]]/(r[[\[Alpha]]]*(r[[\[Alpha]]]+d[[\[Alpha]]])),{\[Alpha],1,4}]
];

By[x_,y_,z_,coil_]:= Module[{a,b,c,d,r, curr,dx,dy,dz},
dx = x - coil[[3]];
dy = y-coil[[4]];
dz = z - coil[[5]];
a = coil[[1]]/2;
b = coil[[2]]/2;
c = {a+dx, a-dx, dx-a, -dx-a};
d = {dy+b, dy+b,dy-b, dy-b};
curr  = coil[[6]];
r={Sqrt[(a+dx)^2+(dy+b)^2+dz^2],Sqrt[(a-dx)^2+(dy+b)^2+dz^2],Sqrt[(a-dx)^2+(dy-b)^2+dz^2],
Sqrt[(a+dx)^2+(dy-b)^2+dz^2]} ;
\[Mu]0*curr/4/\[Pi]*Sum[((-1)^(\[Alpha]+1)*dz)/(r[[\[Alpha]]]*(r[[\[Alpha]]]+ (-1)^(\[Alpha]+1)*c[[\[Alpha]]])),{\[Alpha],1,4}]
];

Bx[x_,y_,z_,coil_]:= Module[{a,b,c,d,r, curr,dx,dy,dz},
dx = x - coil[[3]];
dy = y-coil[[4]];
dz = z - coil[[5]];
a = coil[[1]]/2;
b = coil[[2]]/2;
c = {a+dx, a-dx, dx-a, -dx-a};
d = {dy+b, dy+b,dy-b, dy-b};
curr  = coil[[6]];
r={Sqrt[(a+dx)^2+(dy+b)^2+dz^2],Sqrt[(a-dx)^2+(dy+b)^2+dz^2],Sqrt[(a-dx)^2+(dy-b)^2+dz^2],
Sqrt[(a+dx)^2+(dy-b)^2+dz^2]} ;
\[Mu]0*curr/4/\[Pi]*Sum[((-1)^(\[Alpha]+1)*dz)/(r[[\[Alpha]]]*(r[[\[Alpha]]]+d[[\[Alpha]]])),{\[Alpha],1,4}]
];

BxField[x_,y_,z_,coils_]:=Module[{},TempFunc[coil_]:=Bx[x,y,z,coil];
Plus@@Map[TempFunc,coils,{1}]];

ByField[x_,y_,z_,coils_]:=Module[{},TempFunc[coil_]:=By[x,y,z,coil];
Plus@@Map[TempFunc,coils,{1}]];

BzField[x_,y_,z_,coils_]:=Module[{},TempFunc[coil_]:=Bz[x,y,z,coil];
Plus@@Map[TempFunc,coils,{1}]];

BxSum[x_,y_,z_,transfer_,MOT_,Ybias_,Zbias_,FF_] :=  BxField[x,y-TransferCoils[0][[8]],z,transfer]+BxField[x,y-MOTCoils[0][[8]],z,MOT]+BzField[-z,y-YbiasCoils[0][[8]],x,Ybias]+BxField[x,y-FFCoils[0][[8]],z,FF]+BxField[x,-z,y-ZbiasCoils[0][[8]],Zbias];

BySum[x_,y_,z_,transfer_,MOT_,Ybias_,Zbias_,FF_] :=  ByField[x,y-TransferCoils[0][[8]],z,transfer]+ByField[x,y-MOTCoils[0][[8]],z,MOT]+ByField[-z,y-YbiasCoils[0][[8]],x,Ybias]+ByField[x,y-FFCoils[0][[8]],z,FF]+BzField[x,-z,y-ZbiasCoils[0][[8]],Zbias];

BzSum[x_,y_,z_,transfer_,MOT_,Ybias_,Zbias_,FF_] :=  BzField[x,y-TransferCoils[0][[8]],z,transfer]+BzField[x,y-MOTCoils[0][[8]],z,MOT]+BxField[-z,y-YbiasCoils[0][[8]],x,Ybias]+BzField[x,y-FFCoils[0][[8]],z,FF]+ByField[x,-z,y-ZbiasCoils[0][[8]],Zbias];

FieldMag[x_,y_,z_,transfer_,MOT_,Ybias_,Zbias_,FF_]:= Sqrt[BxSum[x,y,z,transfer,MOT,Ybias,Zbias,FF]^2+BySum[x,y,z,transfer,MOT,Ybias,Zbias,FF]^2+BzSum[x,y,z,transfer,MOT,Ybias,Zbias,FF]^2];

BiasCoils[coils_]:=Module[{length,h,r,hreal,heightreal,widthreal,biascoils,wiredia,current,width,height,coilspacing,hmax,rmax,distfromcenter},
biascoils={};
length=0;
wiredia = coils[[1]];
current = coils[[2]];
width = coils[[3]];
height = coils[[4]];
coilspacing = coils[[5]];
hmax = coils[[6]];
rmax = coils[[7]];
For[h=0,h<hmax,h++,
For[r=0,r<rmax,r++,
hreal=coilspacing/2+wiredia/2+h*wiredia; (*how many layers along the z axis direction *)
heightreal = height+2*(wiredia/2+r*wiredia);(*how many turns in one plane *)
widthreal = width + 2*(wiredia/2+r * wiredia);
AppendTo[biascoils,{widthreal, heightreal,0,0,hreal,current}];
AppendTo[biascoils,{widthreal,heightreal,0,0,-hreal,current}];
length = length + 2*(widthreal+heightreal);]];
Return[biascoils]
]

BiasCoilsAntiHH[coils_]:=Module[{length,h,r,hreal,heightreal,widthreal,biascoils,wiredia,current,width,height,coilspacing,hmax,rmax,distfromcenter},
biascoils={};
length=0;
wiredia = coils[[1]];
current = coils[[2]];
width = coils[[3]];
height = coils[[4]];
coilspacing = coils[[5]];
hmax = coils[[6]];
rmax = coils[[7]];
For[h=0,h<hmax,h++,
For[r=0,r<rmax,r++,
hreal=coilspacing/2+wiredia/2+h*wiredia; (*how many layers along the z axis direction *)
heightreal = height+2*(wiredia/2+r*wiredia);(*how many turns in one plane *)
widthreal = width + 2*(wiredia/2+r * wiredia);
AppendTo[biascoils,{widthreal, heightreal,0,0,hreal,current}];
AppendTo[biascoils,{widthreal,heightreal,0,0,-hreal,-current}];
length = length + 2*(widthreal+heightreal);]];
Return[biascoils]
]

MagTrapField[x_,y_,z_,currents_,trapparams_]:=Module[{d1,d2,d3,iD1,iD2,iD3,iT,iM,iY,iZ,iFF,trace1,trace2,VecField,transfer,MOT,Ybias,Zbias,FF,Gravity},
iT = currents[[4]];
iM = currents[[5]];
iY = currents[[6]];
iZ = currents[[7]];
iFF = currents[[8]];
transfer = BiasCoils[TransferCoils[iT]];
MOT = BiasCoils[MOTCoils[iM]];
Ybias = BiasCoils[YbiasCoils[iY]];
Zbias = BiasCoils[ZbiasCoils[iZ]];
FF=BiasCoils[FFCoils[iFF]]; 
VecField = 
 {BzSum[x,y,z,transfer,MOT,Ybias,Zbias,FF],BxSum[x,y,z,transfer,MOT,Ybias,Zbias,FF],BySum[x,y,z,transfer,MOT,Ybias,Zbias,FF]};
Return[Sqrt[VecField.VecField]]
]

Xwire[x0_,y0_,z0_,hw_,wirecoord_]:=Module[{dx1,dx2,dyPlus,dyMinus,yc,x1,x2},
yc = wirecoord[[1]];
x1 = wirecoord[[2]];
x2 = wirecoord[[3]];
dx1=-x0+x1;
dx2=-x0+x2;
dyPlus=hw-y0+yc;
dyMinus=hw+y0-yc;
Return[10^-7/(2hw) {0,ArcTan[(dx1 dyMinus)/(z0 Sqrt[dx1^2+dyMinus^2+z0^2])]-ArcTan[(dx2 dyMinus)/(z0 Sqrt[dx2^2+dyMinus^2+z0^2])]+ArcTan[(dx1 dyPlus)/(z0 Sqrt[dx1^2+dyPlus^2+z0^2])]-ArcTan[(dx2 dyPlus)/(z0 Sqrt[dx2^2+dyPlus^2+z0^2])],Log[(dx1+Sqrt[dx1^2+dyMinus^2+z0^2])/(dx2+Sqrt[dx2^2+dyMinus^2+z0^2]) (dx2+Sqrt[dx2^2 + dyPlus^2 + z0^2])/(dx1+Sqrt[dx1^2+dyPlus^2+z0^2])]}];
];

(* *************************
Ywire code edited on 0501 2019 in response to Nathan Lundblad email citing an error in the original NASA JPL code. Z component should have a negative sign prior to the "Log[...]".
************************** *)

Ywire[x0_,y0_,z0_,hw_,wirecoord_]:=Module[{dxPlus,dxMinus,dy1,dy2,xc,y1,y2},
xc = wirecoord[[1]];
y1 = wirecoord[[2]];
y2 = wirecoord[[3]];
dxPlus=hw+x0-xc;
dxMinus=hw-x0+xc;
dy1=y0-y1;
dy2=-y0+y2;
Return[10^-7/(2 hw) {ArcTan[(dxPlus dy1)/(z0 Sqrt[dxPlus^2+dy1^2+z0^2])]+ArcTan[(dxMinus dy1)/(z0 Sqrt[dxMinus^2+dy1^2+z0^2])]+ArcTan[(dxPlus dy2)/(z0 Sqrt[dxPlus^2+dy2^2+z0^2])]+ArcTan[(dxMinus dy2)/(z0 Sqrt[dxMinus^2+dy2^2+z0^2])],0,-Log[(-dy1+Sqrt[dxPlus^2+dy1^2+z0^2])/(-dy1+Sqrt[dxMinus^2+dy1^2+z0^2]) (dy2+Sqrt[dxMinus^2+dy2^2+z0^2])/(dy2+Sqrt[dxPlus^2+dy2^2+z0^2])]}];
];
                                  
ChipTrapField[x_,y_,z_,currents_,trapparams_]:=Module[{d1,d2,d3,iD1,iD2,iD3,iT,iM,iY,iZ,iFF,drive1,drive2,drive3,VecField,transfer,MOT,Ybias,Zbias,FF,Gravity},
iD1 = currents[[1]];
iD2 = currents[[2]];
iD3 = currents[[3]];
iT = currents[[4]];
iM = currents[[5]];
iY = currents[[6]];
iZ = currents[[7]];
iFF = currents[[8]];
d1 = trapparams[[4]];
d2 = trapparams[[5]];
d3 = trapparams[[6]];
transfer = BiasCoils[TransferCoils[iT]];
MOT = BiasCoils[MOTCoils[iM]];
Ybias = BiasCoils[YbiasCoils[iY]];
Zbias = BiasCoils[ZbiasCoils[iZ]];
FF=BiasCoils[FFCoils[iFF]];

drive1 =  Which[
d1=="Z1",(Ywire[x,y,z,WireWidth,Za[[1]]]+Xwire[x,y,z,WireWidth,Za[[2]]]+Ywire[x,y,z,WireWidth,Za[[3]]]),
d1=="L2",(Ywire[x,y,z,WireWidth,Lb[[2]]]+Xwire[x,y,z,WireWidth,Lb[[2]]]+Ywire[x,y,z,WireWidth,Lb[[3]]]),
d1=="T2",(Ywire[x,y,z,WireWidth,Tb[[1]]]+Xwire[x,y,z,WireWidth,Tb[[2]]]+Ywire[x,y,z,WireWidth,Tb[[3]]]),
d1=="Z2", Return["Z2 is not a valid option for driver 1. Please choose Z1, L2, T2 or None."],
d1=="L1", Return["L1 is not a valid option for driver 1. Please choose Z1, L2, T2 or None."],
d1=="FF", Return["FF is not a valid option for driver 1. Please choose Z1, L2, T2 or None."],
d1=="H", Return["H is not a valid option for driver 1. Please choose Z1, L2, T2 or None."],
d1!="Z1"\[Or]"L2"\[Or]"T2"\[Or]"Z2"\[Or]"L1"\[Or]"FF"\[Or]"H", Return["ERROR. The wire name you entered for 
driver 1 does not exist in this program. Valid wire names for driver 1 are Z1, L2, T2 or None."],
d1=="None",0];

drive2 = Which[
d2=="Z2",(Ywire[x,y,z,WireWidth,Zb[[1]]]+Xwire[x,y,z,WireWidth,Zb[[2]]]+Ywire[x,y,z,WireWidth,Zb[[3]]]),
d2=="L1",(Ywire[x,y,z,WireWidth,La[[1]]]+Xwire[x,y,z,WireWidth,La[[2]]]+Ywire[x,y,z,WireWidth,La[[3]]]),
d2=="FF",0,
d2=="Z1", Return["Z1 is not a valid option for driver 2. Please choose Z2, L1, FF or None."],
d2=="L2", Return["L2 is not a valid option for driver 2. Please choose Z2, L1, FF or None."],
d2=="T2", Return["T2 is not a valid option for driver 2. Please choose Z2, L1, FF or None."],
d2=="H", Return["H is not a valid option for driver 2. Please choose Z2, L1, FF or None."],
d2!="Z1"\[Or]"L2"\[Or]"T2"\[Or]"Z2"\[Or]"L1"\[Or]"FF"\[Or]"H", Return["ERROR. The wire name you entered for 
driver 2 does not exist in this program. Valid wire names for driver 2 are Z2, L1, FF or None."],
d2=="None",0];

drive3 = Which[
d3=="H",(Ywire[x,y,z-Hoffset,200\[Mu]m,Ha[[1]]]+Ywire[x,y,z-Hoffset,200\[Mu]m,Hb[[1]]]),
d3=="Z1", Return["Z1 is not a valid option for driver 3. Please choose H or None."],
d3=="L2", Return["L2 is not a valid option for driver 3. Please choose H or None."],
d3=="T2", Return["T2 is not a valid option for driver 3. Please choose H or None."],
d3=="Z2", Return["Z2 is not a valid option for driver 3. Please choose H or None."],
d3=="L1", Return["L1 is not a valid option for driver 3. Please choose H or None."],
d3=="FF", Return["FF is not a valid option for driver 3. Please choose H or None."],
d3!="Z1"\[Or]"L2"\[Or]"T2"\[Or]"Z2"\[Or]"L1"\[Or]"FF"\[Or]"H", Return["ERROR. The wire name you entered for 
driver 3 does not exist in this program. Valid wire names for driver 3 are H or None."],
d3=="None",0];

VecField = iD1*drive1 + iD2*drive2 + iD3*drive3 + {BzSum[x,y,z,transfer,MOT,Ybias,Zbias,FF],BxSum[x,y,z,transfer,MOT,Ybias,Zbias,FF],BySum[x,y,z,transfer,MOT,Ybias,Zbias,FF]};
Return[Sqrt[VecField.VecField]]
]
(*
***********************************new functions************************************** 
***********************************new functions**************************************
***********************************new functions**************************************
*)
convertCurrentsBToME[batesCurrents_]:=
Module[
{
(* Bates currents *)
currLa = batesCurrents[[1]],
currZa = batesCurrents[[2]],
currLb = batesCurrents[[3]],
currZb = batesCurrents[[4]],
currH = batesCurrents[[5]],
currBiasX = batesCurrents[[6]],
currBiasY = batesCurrents[[7]],
currBiasZ = batesCurrents[[8]],
(* ME currents *)
IDriver1,
IDriver2,
IDriver3,
ITransferCoils,
IMOTCoils,
IYBiasCoils,
IZBiasCoils,
IFFCoils,
(* Check input validity *)
validCurr1, validCurr2
},
(* Bates convention doesn't define currents for the
MOT or Fast-Feschbach coils, so we set those values to 0: *)
IMOTCoils = 0.;
IFFCoils = 0.;
(* The bias coils correspond directly: *)
ITransferCoils = currBiasX;
IYBiasCoils = currBiasY;
IZBiasCoils = currBiasZ;
(* Driver three is responsible only for the H wires, and so can
be assigned directly: *)
IDriver3 = currH;
(* Wires Za and Lb are both driven by driver 1 (AZ1) and
wires Zb and La are driven by driver 2 (AZ2). Thus one current
of each of those pairs should be 0 [OR UNDEFINED!]. *)
IDriver1 = currZa + currLb;
IDriver2 = currZb + currLa;
validCurr1 = (IDriver1==currZa Or IDriver1==currLb);
validCurr2 = (IDriver2==currZb Or IDriver2==currLa);
(* Check that the input currents are valid, accurately reflecting
from which driver they are driven. *)
If[Not@validCurr1,
Return["Either currZa (currents[[2]]) or currLb (currents[[3]])
must be 0, because they are driven with the same driver."]
];
If[Not@validCurr2,
Return["Either currZb (currents[[4]]) or currLa (currents[[1]])
must be 0, because they are driven with the same driver."]
];

Return[
{IDriver1, IDriver2, IDriver3, 
ITransferCoils, IMOTCoils, IYBiasCoils, IZBiasCoils, IFFCoils}];
];

convertCoorBToME[batesCoordinates_]:=
{#[[1]], #[[2]]-0.001, #[[3]]}&[batesCoordinates];

convertCoorMEToB[meCoordinates_]:=
{#[[1]], #[[2]]+0.001, #[[3]]}&[meCoordinates];
(*
************************************************************************************
*)
(* MagTrapVecField is a copy of MagTrapField, except the output is left as a magnetic field
vector {Bx, By, Bz}, in Tesla. *)
MagTrapVecField[x_,y_,z_,currents_,trapparams_]:=Module[{d1,d2,d3,iD1,iD2,iD3,iT,iM,iY,iZ,iFF,drive1,drive2,drive3,VecField,transfer,MOT,Ybias,Zbias,FF,Gravity},
iD1 = currents[[1]];
iD2 = currents[[2]];
iD3 = currents[[3]];
iT = currents[[4]];
iM = currents[[5]];
iY = currents[[6]];
iZ = currents[[7]];
iFF = currents[[8]];
d1 = trapparams[[4]];
d2 = trapparams[[5]];
d3 = trapparams[[6]];
transfer = BiasCoils[TransferCoils[iT]];
MOT = BiasCoils[MOTCoils[iM]];
Ybias = BiasCoils[YbiasCoils[iY]];
Zbias = BiasCoils[ZbiasCoils[iZ]];
FF=BiasCoils[FFCoils[iFF]];

drive1 =  Which[
d1=="Z1",(Ywire[x,y,z,WireWidth,Za[[1]]]+Xwire[x,y,z,WireWidth,Za[[2]]]+Ywire[x,y,z,WireWidth,Za[[3]]]),
d1=="L2",(Ywire[x,y,z,WireWidth,Lb[[2]]]+Xwire[x,y,z,WireWidth,Lb[[2]]]+Ywire[x,y,z,WireWidth,Lb[[3]]]),
d1=="T2",(Ywire[x,y,z,WireWidth,Tb[[1]]]+Xwire[x,y,z,WireWidth,Tb[[2]]]+Ywire[x,y,z,WireWidth,Tb[[3]]]),
d1=="Z2", Return["Z2 is not a valid option for driver 1. Please choose Z1, L2, T2 or None."],
d1=="L1", Return["L1 is not a valid option for driver 1. Please choose Z1, L2, T2 or None."],
d1=="FF", Return["FF is not a valid option for driver 1. Please choose Z1, L2, T2 or None."],
d1=="H", Return["H is not a valid option for driver 1. Please choose Z1, L2, T2 or None."],
d1!="Z1"\[Or]"L2"\[Or]"T2"\[Or]"Z2"\[Or]"L1"\[Or]"FF"\[Or]"H", Return["ERROR. The wire name you entered for 
driver 1 does not exist in this program. Valid wire names for driver 1 are Z1, L2, T2 or None."],
d1=="None",0];

drive2 = Which[
d2=="Z2",(Ywire[x,y,z,WireWidth,Zb[[1]]]+Xwire[x,y,z,WireWidth,Zb[[2]]]+Ywire[x,y,z,WireWidth,Zb[[3]]]),
d2=="L1",(Ywire[x,y,z,WireWidth,La[[1]]]+Xwire[x,y,z,WireWidth,La[[2]]]+Ywire[x,y,z,WireWidth,La[[3]]]),
d2=="FF",0,
d2=="Z1", Return["Z1 is not a valid option for driver 2. Please choose Z2, L1, FF or None."],
d2=="L2", Return["L2 is not a valid option for driver 2. Please choose Z2, L1, FF or None."],
d2=="T2", Return["T2 is not a valid option for driver 2. Please choose Z2, L1, FF or None."],
d2=="H", Return["H is not a valid option for driver 2. Please choose Z2, L1, FF or None."],
d2!="Z1"\[Or]"L2"\[Or]"T2"\[Or]"Z2"\[Or]"L1"\[Or]"FF"\[Or]"H", Return["ERROR. The wire name you entered for 
driver 2 does not exist in this program. Valid wire names for driver 2 are Z2, L1, FF or None."],
d2=="None",0];

drive3 = Which[
d3=="H",(Ywire[x,y,z-Hoffset,200\[Mu]m,Ha[[1]]]+Ywire[x,y,z-Hoffset,200\[Mu]m,Hb[[1]]]),
d3=="Z1", Return["Z1 is not a valid option for driver 3. Please choose H or None."],
d3=="L2", Return["L2 is not a valid option for driver 3. Please choose H or None."],
d3=="T2", Return["T2 is not a valid option for driver 3. Please choose H or None."],
d3=="Z2", Return["Z2 is not a valid option for driver 3. Please choose H or None."],
d3=="L1", Return["L1 is not a valid option for driver 3. Please choose H or None."],
d3=="FF", Return["FF is not a valid option for driver 3. Please choose H or None."],
d3!="Z1"\[Or]"L2"\[Or]"T2"\[Or]"Z2"\[Or]"L1"\[Or]"FF"\[Or]"H", Return["ERROR. The wire name you entered for 
driver 3 does not exist in this program. Valid wire names for driver 3 are H or None."],
d3=="None",0];

VecField = iD1*drive1 + iD2*drive2 + iD3*drive3 + {BzSum[x,y,z,transfer,MOT,Ybias,Zbias,FF],BxSum[x,y,z,transfer,MOT,Ybias,Zbias,FF],BySum[x,y,z,transfer,MOT,Ybias,Zbias,FF]};
Return[VecField]
]


(*
***********************************************************************************
***************************COPIED FROM SMThreeChipModel*******************************
*)


printTableValues[table_, OptionsPattern[{hideXs->True, copyable->False}]] := Module[
{AZ1sel, AZ2sel, AZ1, AZ2, H1pH2, T1, T2, X1, X2, Y, Z,
labels = {"AZ1_sel", "AZ2_sel", "AZ1", "AZ2", "H1&H2", "T1", "T2", "X1", "X2", "Y", "Z"},
finalTable,
outputStrings
},

If[OptionValue[hideXs],
(* THEN: *)
labels = Delete[labels, {{8}, {9}}];
finalTable = Delete[table, {{8}, {9}}];
,
(* ELSE: *)
finalTable = table;
];

If[OptionValue[copyable],
(* THEN: *)
labels[[{1,2,5}]]={"AZ1sel","AZ2sel","H1aH2"};
outputStrings = MapThread[#1<>" = "<>ToString[#2]<>";\n"&, {labels, finalTable}];
CellPrint@StringJoin@outputStrings;
,
(* ELSE: *)
Print@TableForm@{labels, finalTable};
];
];


printTrapParameters[trapParameters_,OptionsPattern[{copyable->False, suppressAValues->False}]]:=
Module[
{paraLabels={"CurrLa","CurrZa","CurrLb","CurrZb","CurrH","Bx1","By1","Bz1"},
outputStrings,
startingIndex = 1},

If[OptionValue[suppressAValues],
(* THEN: *)
startingIndex = 3;
paraLabels = ReplacePart[paraLabels,{3->"CurrL", 4->"CurrZ"}];
];

If[Not@OptionValue[copyable],
(* THEN: *)
Print@TableForm@MapThread[{#1,#2}&,{paraLabels,trapParameters}],
(* ELSE: *)
(* Assemble the chip currents first. *)
outputStrings = 
MapThread[#1<>" = "<>ToString[#2]<>"A;\n"&,{paraLabels,trapParameters}][[startingIndex;;5]];

(* Then make strings of the bias coil currents, making the conversion factor explicit. *)

outputStrings=Append[outputStrings,paraLabels[[6]]<>
" = ("<>ToString[trapParameters[[6]]/biasXCalib]<>"A)*"<>ToString[biasXCalib]<>";\n"];

outputStrings=Append[outputStrings,paraLabels[[7]]<>
" = ("<>ToString[trapParameters[[7]]/biasYCalib]<>"A)*"<>ToString[biasYCalib]<>";\n"];

outputStrings=Append[outputStrings,paraLabels[[8]]<>
" = ("<>ToString[trapParameters[[8]]/biasZCalib]<>"A)*"<>ToString[biasZCalib]<>";\n"];

CellPrint@StringJoin@outputStrings;
];
];


(** Current to field magnitude conversion factors for Bias **)
biasXCalib=40.625;(*[G/A]*)
biasYCalib=14.286;(*[G/A]*)
biasZCalib=-10.368;(*[G/A]*)

(** Max current values **)
(* Chip *)
maxCurrentAZ1 = 3.5; (*[A]*)
maxCurrentAZ2 = 3.5; (*[A]*)
maxCurrentH1pH2 = 5.; (*[A}*)

(* Bias coils *)
maxCurrentBiasX = 8.; (*[A]*)
maxCurrentBiasY = 3.02; (*[A]*) (* In some places it is reported as 3. A *)
maxCurrentBiasZ = 3.; (*[A]*)


convertCALTableToCurrents[table_, OptionsPattern[verbose->False]]:=Module[
{
AZ1sel = table[[1]],
AZ2sel = table[[2]],
AZ1 = table[[3]],
AZ2 = table[[4]],
H1pH2 = table[[5]],
T1 = table[[6]],
T2 = table[[7]],
X1 = table[[8]],
X2 = table[[9]],
Y = table[[10]],
Z = table[[11]],
currLa, currZa, currLb, currZb, currH, currBiasX, currBiasY, currBiasZ
},
If[AZ1sel==0,
currZa = AZ1*maxCurrentAZ1*(-1); (* The negative one ensures that a positive AZ1 value results in a current moving in the negative x direction, the convention used to define the chip model below. *)
currLb = 0.;,
(*Else:*)
currZa = 0;
currLb = AZ1*maxCurrentAZ1;
];

If[AZ2sel==0,
currZb = AZ2*maxCurrentAZ2*(-1); (* N.B. AZ2 only takes non-positive values, and so the current through Zb always travels in the positive x direction, if it exists. *)
currLa = 0.;,
(*Else:*)
currZb = 0.;
currLa = AZ2*maxCurrentAZ2; (* N.B. always travels in the negative x direction. *)
];

currH = H1pH2*maxCurrentH1pH2; (* Convention set by the chip model below stipulates that a postive current travels in the negative y direction. The chipdrivers_v3 document suggests (via its green arrows) that this is the convention used by the H driver as well. *)

currBiasX = T1*maxCurrentBiasX;
currBiasY = Y*maxCurrentBiasY;
currBiasZ = Z*maxCurrentBiasZ;

If[OptionValue[verbose],
Print["I evaluated!"];
Print[
"I_La = "<>ToString[currLa]<>"\n"
<>"I_Za = "<>ToString[currZa];
];
];

Return[{currLa, currZa, currLb, currZb, currH, currBiasX, currBiasY, currBiasZ}];
];


convertCALTableToTrapParameters[table_]:=Module[
{currLa, currZa, currLb, currZb, currH, currBiasX, currBiasY, currBiasZ,
fieldBiasX, fieldBiasY, fieldBiasZ},

{currLa, currZa, currLb, currZb, currH, currBiasX, currBiasY, currBiasZ} = 
convertCALTableToCurrents[table];

fieldBiasX = currBiasX*biasXCalib*(-1); (* The origin of this negative one factor is undetermined and troubling. *)
fieldBiasY = currBiasY*biasYCalib;
fieldBiasZ = currBiasZ*biasZCalib;

Return[{currLa, currZa, currLb, currZb, currH, fieldBiasX, fieldBiasY, fieldBiasZ}];
];


convertTrapParametersToCALTable[trapParameters_, OptionsPattern[verbose->False]] := Module[
{currLa, currZa, currLb, currZb, currH, currBiasX, currBiasY, currBiasZ,
fieldBiasX, fieldBiasY, fieldBiasZ,
currentCutoff = 10^(-9),
AZ1sel, AZ2sel, AZ1, AZ2, H1pH2, T1, T2, X1, X2, Y, Z,
table},

(* Name the individual trap parameters *)
{currLa, currZa, currLb, currZb, currH, fieldBiasX, fieldBiasY, fieldBiasZ} = trapParameters;

(* Determine which channel of driver AZ1 is being used, 0 (Za) or 1 (Lb). *)
If[Abs[currLb]<currentCutoff,
(* THEN: *)
AZ1sel = 0;
AZ1 = (-1)*currZa/maxCurrentAZ1;,
(* ELSE: *)
AZ1sel = 1;
AZ1 = currLb/maxCurrentAZ1;
];

(* Do the same for driver AZ2, where the possible channels are 0 (Zb) or 1 (La). *)
If[Abs[currLa]<currentCutoff,
(* THEN: *)
AZ2sel = 0;
AZ2 = (-1)*currZb/maxCurrentAZ2;,
(* ELSE: *)
AZ2sel = 1;
AZ2 = currLa/maxCurrentAZ2;
];

(* Setting the value of driver three, H, is straight-forward: *)
H1pH2 = currH/maxCurrentH1pH2;

(* As is setting the values of the bias fields: *)
T1 = fieldBiasX/(biasXCalib*maxCurrentBiasX*(-1));
T2 = T1;
Y = fieldBiasY/(biasYCalib*maxCurrentBiasY);
Z = fieldBiasZ/(biasZCalib*maxCurrentBiasZ);

table = {AZ1sel, AZ2sel, AZ1, AZ2, H1pH2, T1, T2, X1, X2, Y, Z};

If[OptionValue[verbose],
(* THEN: *)
printTableValues[table];
];

Return[table];
];


(*
***********************************************************************************
*********************END OF COPIED FROM SMThreeChipModel*******************************
*)


(* A ME trapparameters object of the form
{isotope,F,mF,D1,D2,D3}.
*)
batesSpeciesTrapParameters = {
"Rb87", (* species and isotope *)
2, (* Hyperfine manifold F *)
2, (* Hyperfine state mF *)
"L2", (* Chip trace L2 (Channel Lb) *)
"Z2", (* Chip trace Z2 (Channel Zb) *)
"H" (* Chip trace/channel H *)
}

biasMagVecField[x_, y_, z_, coilCurrents_]:=Module[
(* coil currents to be given in the form {LOOK UP FORM!} *)
{xp,yp,zp},
(* Convert the spatial coordinates into the coordinate system used by Mossman,
since all of the subsequent models use those coordinates: *)
{xp,yp,zp} = convertCoorBToME[{x,y,z}];
Return[MagTrapVecField[xp,yp,zp,coilCurrents,batesSpeciesTrapParameters]];
];

biasMagVecFieldLEGACY[x_, y_, z_, bx0_, by0_, bz0_]:=Module[
(* 
This function is designed to be dropped into the current Bates models, where
the effect of each bias magnetic coil is described by a single magnetic field magnitude
per direction, given in Gauss. (The transfer coils are used to generate the bias
field in the x direction, running with equal currents in a Helmholtz configuration.

This is accomplished by taking as inputs magnetic field values in Gauss, which are
now considered to be nominal, and the currents which ideally generate a field with
that magnitude are derived using the conversion factors Bates derived.

These currents are then fed into the Mossman--Engels code for the bias coils.

The values of these currents are calculated using the composite function
convertCALTableToTrapParameters@convertTrapParametersToCALTable .
*)

{xp,yp,zp,
currBX, currBY, currBZ,
coilCurrents},
(* Convert the spatial coordinates into the coordinate system used by Mossman,
since all of the subsequent models use those coordinates: *)
{xp,yp,zp} = convertCoorBToME[{x,y,z}];

(* In order to use the established functions for converting between trap parameters and
the currents which are for them responsible, the NOMINAL (input) bias fields are added
as elements of a list of trap parameters
{currLa, currZa, currLb, currZb, currH, fieldBiasX, fieldBiasY, fieldBiasZ}
*)
{currBX, currBY, currBZ} = 
(convertCALTableToTrapParameters@convertTrapParametersToCALTable@{0, 0, 0, 0, 0, bx0, by0, bz0})[[6;;8]];
(* Note the (currently anamolous) negative signs on the x and z components! I'm trying
to track down their origin, but they are required to give the right field sign. *)

(* Similarly, the currents of the bias coils are embedded in a larger list of currents
so as to use the existing functions for calculating the magnetic fields. 
{I_driver1, I_driver2, I_driver3, 
I_transfercoils, I_MOTcoils, I_ybiascoils, I_zbiascoils, I_FFcoils}
*)
coilCurrents = {0, 0, 0, -currBX, 0, currBY, -currBZ, 0};

Return[MagTrapVecField[xp,yp,zp,coilCurrents,batesSpeciesTrapParameters]];
];


End[] (* End private context *)

EndPackage[]
